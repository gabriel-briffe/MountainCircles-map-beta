<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Airspace</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        
        #sidebar {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            z-index: 2;
            font-family: sans-serif;
            font-size: 14px;
        }
        
        /* Popup styling */
        .popup-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            padding: 0px;
            z-index: 1000;
            /* max-width: 50%; */
            overflow-y: auto;
            overflow-x: hidden;
            display: inline-flex;
        }
        .popup-content {
            flex: 1;
            padding-left: 10px;
            overflow-y: auto;
        }
        .popup-section {
            font-size: 14px;
            border-bottom: 1px solid #ddd;
            padding: 8px;
            /* Make sections look clickable */
            cursor: pointer;
            /* Make text unselectable */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .popup-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .popup-section.highlighted {
            background-color: rgba(64, 224, 208, 0.5);
        }
        .limits-type-container {
            display: flex;
            align-items: center;
        }
        .limits-div {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .upper-limit {
            line-height: 1;
            border-bottom: 1px solid #666;
        }
        .lower-limit {
            line-height: 1;
        }
        .colorBand {
            position: absolute;
            left: -10px;
            top: 0;
            width: 10px;
            height: 100%;
            opacity: 0.7;
        }
        .colorBand-highlighted {
            opacity: 1 !important;
        }
        
        .cross-section {
            border-right: 4px solid #ccc;
            padding: 0;
            background: #f0f0f0;
            position: relative;
        }
        .airspace-bar {
            position: absolute;
            opacity: 0.7;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 10px;
        }
        .airspace-bar.highlighted-bar {
            border: 2px solid rgba(64, 224, 208, 1);
            margin-left: -2px;
            margin-bottom: -2px;
            opacity: 1 !important;
        }
        .altitude-label {
            font-size: 12px;
            line-height: 1;
            font-weight: bold;
            padding: 0;
            white-space: auto;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding-left: 2px;
            padding-right: 2px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }
        .altitude-line {
            position: absolute;
            height: 1px;
            background: #666;
            left: 0;
        }

    </style>
</head>

<body>
    <div id="sidebar">
        <label><input type="checkbox" id="toggleSIV" unchecked> SIV</label><br>
        <label><input type="checkbox" id="toggleFIR" unchecked> FIR</label><br>
        <label><input type="checkbox" id="toggleParks" checked> Parks</label><br>
        <label><input type="checkbox" id="toggleGliding" checked> Gliding</label><br>
        <label><input type="checkbox" id="toggleLTA" checked> LTA</label>
        <hr>
        <label><input type="checkbox" id="toggleProhibited" checked> Prohibited</label><br>
        <label><input type="checkbox" id="toggleRestricted" checked> Restricted</label><br>
        <label><input type="checkbox" id="toggleDangerous" checked> Dangerous</label><br>
        <label><input type="checkbox" id="toggleABCD" checked> A, B, C, D</label><br>
        <label><input type="checkbox" id="toggleEFG" checked> E, F, G</label><br>
        <label><input type="checkbox" id="toggleZSM" checked> ZSM</label><br>
        <label><input type="checkbox" id="toggleRMZ" checked> RMZ</label><br>
        <label><input type="checkbox" id="toggleTMZ" checked> TMZ</label><br>
        <label><input type="checkbox" id="toggleParaVoltige" checked> Para/voltige</label><br>
    </div>

    <div id="map"></div>

    <script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>
    <script type="module">
        import style from "./style.js";
        import { ICAO_CLASS_MAPPING, TYPE_MAPPING, UNIT_MAPPING, REFERENCE_DATUM_MAPPING, COLOR_MAPPING, getColor } from "./mappings.js";

        console.log("Script started, ICAO Mapping:", ICAO_CLASS_MAPPING);

        const displayFields = ["name", "icaoClassTranslated", "typeTranslated", "lowerLimit", "upperLimit"];

        function filterProperties(props, fields) {
            const filtered = {};
            fields.forEach(function (field) {
                if (props.hasOwnProperty(field)) {
                    filtered[field] = props[field];
                }
            });
            return filtered;
        }

        function filterMapFeatures(features) {
            return features.filter(function(feature) {
                const props = feature.properties;
                const layerId = feature.layer && feature.layer.id ? feature.layer.id : '';
                if (layerId.includes("SIV") && !document.getElementById("toggleSIV").checked) return false;
                if (layerId.includes("FIR") && !document.getElementById("toggleFIR").checked) return false;
                if (layerId.includes("gliding") && props.customProperty === "LTA" && !document.getElementById("toggleLTA").checked) return false;
                if (props.type === "Dangerous" && !document.getElementById("toggleDangerous").checked) return false;
                if (["E", "F", "G"].includes(props.icaoClass) && !document.getElementById("toggleEFG").checked) return false;
                return true;
            });
        }

        function triggerPopupRefresh(map) {
            if (document.querySelector('.popup-menu')) {
                refreshAirspacePopup(map);
            }
        }

        // Global variables to remember the last popup location, highlighted feature key, and popup marker.
        let lastPopupLngLat = null;
        let highlightedFeatureKey = null;
        let popupMarker = null;

        // Utility function to generate a unique key for a feature.
        function getFeatureKey(props) {
            return props._id;
        }

        // Helper function which creates a popup section for a feature.
        function buildPopupSection(feature, map, popup) {
            const props = feature.properties;
            const featureKey = getFeatureKey(props);

            // Format header and type
            let header = (props.icaoClass === "Other") ? (props.name || "") : `${props.icaoClass || ''} - ${props.name || ''}`;
            let type = props.type || '';
            if (type && props.name && props.name.startsWith(type)) {
                type = '';
            }

            // Compute the lower limit display
            let lowerDisplay = '';
            if (Number(props.lowerLimitValue) === 0 &&
                props.lowerLimitUnit &&
                props.lowerLimitUnit.toLowerCase() === 'ft') {
                lowerDisplay = props.lowerLimitReferenceDatum || '';
            } else {
                lowerDisplay = props.parsedLowerLimit || '';
            }
            const upperDisplay = props.parsedUpperLimit || '';

            // Create the section
            const section = document.createElement('div');
            section.className = 'popup-section';
            section.style.position = 'relative'; // For the color band
            section.dataset.featureKey = featureKey;

            // Create header
            const headerDiv = document.createElement('div');
            headerDiv.innerHTML = `<strong>${header}</strong>`;
            section.appendChild(headerDiv);

            // Create flex container for limits and type
            const limitsTypeContainer = document.createElement('div');
            limitsTypeContainer.className = 'limits-type-container';

            // Limits stack with underline
            const limitsDiv = document.createElement('div');
            limitsDiv.className = 'limits-div';

            const upperLimitDiv = document.createElement('div');
            upperLimitDiv.textContent = upperDisplay;
            upperLimitDiv.className = 'upper-limit';
            limitsDiv.appendChild(upperLimitDiv);

            const lowerLimitDiv = document.createElement('div');
            lowerLimitDiv.textContent = lowerDisplay;
            lowerLimitDiv.className = 'lower-limit';
            limitsDiv.appendChild(lowerLimitDiv);

            limitsTypeContainer.appendChild(limitsDiv);

            // Type on the right
            if (type) {
                const typeDiv = document.createElement('div');
                typeDiv.textContent = type;
                typeDiv.style.marginLeft = '10px'; // Space between limits and type
                limitsTypeContainer.appendChild(typeDiv);
            }

            section.appendChild(limitsTypeContainer);

            // Add the colored band
            const colorBand = document.createElement('div');
            colorBand.className = 'colorBand';
            colorBand.style.backgroundColor = getColor(props);
            section.appendChild(colorBand);

            // Add frequency info if frequencies exist
            if (props.frequencies &&
                Array.isArray(JSON.parse(props.frequencies)) &&
                JSON.parse(props.frequencies).length > 0) {
                const freqContainer = document.createElement("div");
                // freqContainer.style.marginTop = "4px";

                let frequencies = JSON.parse(props.frequencies);
                frequencies.sort((a, b) => (a.primary === b.primary ? 0 : (a.primary ? -1 : 1)));

                frequencies.forEach(freq => {
                    const freqElem = document.createElement("div");
                    freqElem.style.color = "darkgreen";
                    freqElem.style.fontSize = "0.9em";
                    let freqDisplay = `${freq.name ? freq.name.toUpperCase() : ''} ${freq.value}`;
                    if (freq.primary) {
                        freqDisplay += ` <em>primary</em>`;
                    }
                    freqElem.innerHTML = freqDisplay;
                    freqContainer.appendChild(freqElem);
                });

                section.appendChild(freqContainer);
            }

            return section;
        }

        /* Add the updatePopupStyle function near the top of the script, for example after the filterProperties function */
        function updatePopupStyle() {
            const popup = document.querySelector('.popup-menu');
            if (!popup) return;
            const mapEl = document.getElementById('map');
            if (window.innerWidth > window.innerHeight) {
                // Landscape mode
                popup.style.maxWidth = '50%';
                popup.style.width = 'fit-content';
                popup.style.maxHeight = mapEl.clientHeight + 'px';
                popup.style.right = '0px';
                popup.style.top = '50%';
                popup.style.bottom = '';
                popup.style.transform = 'translateY(-50%)';
            } else {
                // Portrait mode
                popup.style.maxWidth = '100%';
                popup.style.width = 'fit-content';
                popup.style.maxHeight = (mapEl.clientHeight * 0.5) + 'px';
                popup.style.right = '0px';
                popup.style.top = '';
                popup.style.bottom = '0px';
                popup.style.transform = '';
            }
        }

        /* Add event listeners to update popup style when window resizes or orientation changes */
        window.addEventListener('resize', updatePopupStyle);
        window.addEventListener('orientationchange', updatePopupStyle);

        function createAirspacePopup(e, features, map) {
            // Remove any existing popup
            const existing = document.querySelector('.popup-menu');
            if (existing) {
                existing.remove();
            }

            // Create the popup container
            const popup = document.createElement('div');
            popup.className = 'popup-menu';
            popup.style.display = 'inline-flex';

            // Append the popup to the map container
            document.getElementById('map').appendChild(popup);

            // Call updatePopupStyle to set appropriate styling based on orientation
            updatePopupStyle();

            // Create containers and continue building popup
            const crossSectionContainer = document.createElement('div');
            crossSectionContainer.className = 'cross-section';

            const contentContainer = document.createElement('div');
            contentContainer.className = 'popup-content';

            // Store references to bars and sections for highlighting
            const barRefs = new Map(); // Map feature index to bar element
            const sectionRefs = new Map(); // Map feature index to section element

            // New helper function to toggle highlighting for a feature
            function toggleFeatureHighlight(feature, index) {
                const section = sectionRefs.get(index);
                const bar = barRefs.get(index);
                const alreadyHighlighted = section ? section.classList.contains('highlighted') : false;
                if (alreadyHighlighted) {
                    sectionRefs.forEach(s => {
                        s.classList.remove('highlighted');
                        let cb = s.querySelector('.colorBand');
                        if (cb) cb.classList.remove('colorBand-highlighted');
                    });
                    barRefs.forEach(b => b.classList.remove('highlighted-bar'));
                    map.getSource('highlight-airspace-source').setData({ type: 'FeatureCollection', features: [] });
                    highlightedFeatureKey = null;
                } else {
                    sectionRefs.forEach(s => {
                        s.classList.remove('highlighted');
                        let cb = s.querySelector('.colorBand');
                        if (cb) cb.classList.remove('colorBand-highlighted');
                    });
                    barRefs.forEach(b => b.classList.remove('highlighted-bar'));
                    if (section) {
                        section.classList.add('highlighted');
                        let cb = section.querySelector('.colorBand');
                        if (cb) cb.classList.add('colorBand-highlighted');
                    }
                    if (bar) {
                        bar.classList.add('highlighted-bar');
                    }
                    map.getSource('highlight-airspace-source').setData({
                        type: 'FeatureCollection',
                        features: [feature]
                    });
                    highlightedFeatureKey = getFeatureKey(feature.properties);
                    // Scroll the highlighted section into view smoothly
                    if (section) {
                        section.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                    }
                }
            }

            // Build content first (sections)
            if (features.length) {
                features.sort((a, b) => (b.properties.lowerLimitMeters || 0) - (a.properties.lowerLimitMeters || 0));
                features.forEach((feature, index) => {
                    const section = buildPopupSection(feature, map, popup);
                    section.dataset.featureIndex = index; // Assign unique identifier
                    sectionRefs.set(index, section);

                    // Updated click handler for sections using helper function
                    section.addEventListener('click', () => {
                        toggleFeatureHighlight(feature, index);
                    });

                    contentContainer.appendChild(section);
                });
            } else {
                contentContainer.innerHTML = "<p>No Airspace found at this location, MAX FL115 / FL195 in France.</p>";
            }

            // Assemble popup with content
            popup.appendChild(crossSectionContainer);
            popup.appendChild(contentContainer);

            // Build cross-section with bars
            const heightScale = popup.clientHeight;
            if (features.length) {
                const maxUpperLimit = Math.max(...features.map(f => f.properties.upperLimitMeters || 0));
                const barWidth = 20;
                const barSpacing = 5;

                // Track bar positions and collect unique altitudes with parsed values
                const columns = [];
                const altitudeSet = new Set(); // Will store [meters, parsed] tuples
                features.forEach((feature, index) => {
                    const lowerLimitMeters = feature.properties.lowerLimitMeters || 0;
                    const upperLimitMeters = feature.properties.upperLimitMeters || 0;
                    const parsedLowerLimit = feature.properties.parsedLowerLimit || '';
                    const parsedUpperLimit = feature.properties.parsedUpperLimit || '';

                    // Add tuples to the Set
                    altitudeSet.add(JSON.stringify([lowerLimitMeters, parsedLowerLimit]));
                    altitudeSet.add(JSON.stringify([upperLimitMeters, parsedUpperLimit]));

                    const yUpper = (upperLimitMeters / maxUpperLimit) * 100;
                    const yLower = (lowerLimitMeters / maxUpperLimit) * 100;
                    const barHeight = yUpper - yLower;

                    let placed = false;
                    for (let col of columns) {
                        let canPlace = true;
                        for (let existingBar of col) {
                            const existingLower = existingBar.lowerLimit;
                            const existingUpper = existingBar.upperLimit;
                            if (!(upperLimitMeters <= existingLower || lowerLimitMeters >= existingUpper)) {
                                canPlace = false;
                                break;
                            }
                        }
                        if (canPlace) {
                            col.push({ lowerLimit: lowerLimitMeters, upperLimit: upperLimitMeters, feature, index });
                            placed = true;
                            break;
                        }
                    }
                    if (!placed) {
                        columns.push([{ lowerLimit: lowerLimitMeters, upperLimit: upperLimitMeters, feature, index }]);
                    }
                });

                // Draw bars with click handlers (unchanged)
                let totalWidth = 0;
                columns.forEach((column, colIndex) => {
                    const xPos = barSpacing + colIndex * (barWidth + barSpacing);
                    column.forEach(({ lowerLimit, upperLimit, feature, index }) => {
                        const yUpper = (upperLimit / maxUpperLimit) * 100;
                        const yLower = (lowerLimit / maxUpperLimit) * 100;
                        const barHeight = yUpper - yLower;

                        if (barHeight <= 0) {
                            console.warn(`Invalid bar height for ${feature.properties.icaoClass || feature.properties.type}: ${barHeight}%`);
                            return;
                        }

                        const bar = document.createElement('div');
                        bar.className = 'airspace-bar';
                        bar.style.left = `${xPos}px`;
                        bar.style.bottom = `${yLower}%`;
                        bar.style.width = `${barWidth}px`;
                        bar.style.height = `${barHeight}%`;
                        bar.style.backgroundColor = getColor(feature.properties);
                        barRefs.set(index, bar);

                        // Updated click handler for bars using helper function
                        bar.addEventListener('click', () => {
                            toggleFeatureHighlight(feature, index);
                        });

                        crossSectionContainer.appendChild(bar);
                    });
                    totalWidth = xPos + barWidth;
                });

                // Set container width
                totalWidth += barSpacing;
                const width = Math.max(totalWidth, 60);
                crossSectionContainer.style.width = `${width}px`;

                // Add unique altitude labels using parsed values
                const altitudes = Array.from(altitudeSet)
                    .map(item => JSON.parse(item)) // Convert back from string to [meters, parsed] array
                    .sort((a, b) => b[0] - a[0]); // Sort by meters (first element)
                altitudes.forEach(([altitudeMeters, parsedAltitude]) => {
                    const yPos = (altitudeMeters / maxUpperLimit) * 100;
                    const label = document.createElement('div');
                    label.className = 'altitude-label';
                    label.textContent = parsedAltitude; // Use the parsed value instead of meters
                    label.style.bottom = `calc(${yPos}% - 12px)`;
                    crossSectionContainer.appendChild(label);

                    const line = document.createElement('div');
                    line.className = 'altitude-line';
                    line.style.bottom = `${yPos}%`;
                    line.style.width = `${width}px`;
                    crossSectionContainer.appendChild(line);
                });
            }
        }
        function refreshAirspacePopup(map) {
            if (!lastPopupLngLat) return; // No popup to refresh if no location is stored

            // Re-query features at the last clicked point
            const currentPoint = map.project(lastPopupLngLat);
            let refreshedFeatures = map.queryRenderedFeatures(currentPoint, {
                layers: ["SIV-fill", "gliding-fill", "parks-fill", "FIR-fill", "other-fill"]
            });

            // Apply the same filtering as in the click handler
            refreshedFeatures = filterMapFeatures(refreshedFeatures);

            // Remove the existing popup
            const existingPopup = document.querySelector('.popup-menu');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Recreate the popup with the refreshed features
            createAirspacePopup({ lngLat: lastPopupLngLat }, refreshedFeatures, map);

            // Reapply the highlight if there was a highlighted feature
            if (highlightedFeatureKey) {
                const newPopup = document.querySelector('.popup-menu');
                if (newPopup) {
                    const highlightedSection = newPopup.querySelector(`.popup-section[data-feature-key="${highlightedFeatureKey}"]`);
                    if (highlightedSection) {
                        highlightedSection.click(); // Trigger the click to reapply highlight
                    } else {
                        // If the highlighted feature is no longer present, clear the highlight
                        clearHighlight(map);
                    }
                }
            }
        }

        function clearHighlight(map) {
            if (map.getSource('highlight-airspace-source')) {
                map.getSource('highlight-airspace-source').setData({ type: 'FeatureCollection', features: [] });
            }
            highlightedFeatureKey = null;
            if (popupMarker) {
                popupMarker.remove();
                popupMarker = null;
            }
        }


        async function initializeApp() {
            console.log("initializeApp started");

            if ('serviceWorker' in navigator) {
                if (navigator.serviceWorker.controller) {
                    console.log("Page already controlled by service worker:", navigator.serviceWorker.controller.scriptURL);
                } else {
                    console.log("No controller, registering service worker");
                    try {
                        const registration = await navigator.serviceWorker.register('sw2.js', { scope: './' });
                        console.log("Forcing service worker update");
                        await registration.update();

                        if (registration.waiting) {
                            console.log("Skipping waiting phase");
                            registration.waiting.postMessage({ type: 'SKIP_WAITING' });
                        }
                        if (registration.installing) {
                            console.log("Waiting for installing worker to activate");
                            await new Promise(resolve => {
                                registration.installing.addEventListener('statechange', () => {
                                    if (registration.installing.state === 'activated') resolve();
                                });
                            });
                        }

                        console.log("Waiting for service worker to be ready");
                        await navigator.serviceWorker.ready;
                        console.log('Service Worker active:', registration.scope);

                        if (!navigator.serviceWorker.controller) {
                            console.log("No controller after registration, forcing reload");
                            window.location.reload();
                            return;
                        }
                    } catch (error) {
                        console.error('Service Worker registration failed:', error);
                    }
                }
            } else {
                console.log("Service workers not supported");
            }

            console.log("Initializing map");
            const map = new maplibregl.Map({
                container: 'map',
                style: style,
                center: [2.2137, 46.2276],
                zoom: 5,
                doubleClickZoom: false
            });

            map.on('load', function () {
                console.log("Map loaded");

                // Add the highlight layer source and layer.
                if (!map.getSource('highlight-airspace-source')) {
                    map.addSource('highlight-airspace-source', {
                        type: 'geojson',
                        data: { type: 'FeatureCollection', features: [] }
                    });
                }
                if (!map.getLayer('highlight-airspace')) {
                    map.addLayer({
                        id: 'highlight-airspace',
                        type: 'fill',
                        source: 'highlight-airspace-source',
                        paint: {
                            'fill-color': 'rgba(64,224,208,0.5)',
                            'fill-outline-color': 'rgba(64,224,208,1)'
                        }
                    });
                }

                // SIV layer toggle
                const sivCheckbox = document.getElementById("toggleSIV");
                sivCheckbox.addEventListener("change", function () {
                    if (map.getLayer("SIV-outline")) {
                        const visibility = sivCheckbox.checked ? 'visible' : 'none';
                        map.setLayoutProperty("SIV-outline", "visibility", visibility);
                        console.log("SIV layer visibility set to", visibility);
                    } else {
                        console.log("Layer SIV not found");
                    }
                    // Refresh popup if it's open.
                    triggerPopupRefresh(map);
                });

                // FIR layer toggle
                const firCheckbox = document.getElementById("toggleFIR");
                firCheckbox.addEventListener("change", function () {
                    if (map.getLayer("FIR-outline")) {
                        const visibility = firCheckbox.checked ? 'visible' : 'none';
                        map.setLayoutProperty("FIR-outline", "visibility", visibility);
                        console.log("FIR layer visibility set to", visibility);
                    } else {
                        console.log("Layer FIR not found");
                    }
                    triggerPopupRefresh(map);
                });

                // Parks layer toggle
                const parksCheckbox = document.getElementById("toggleParks");
                parksCheckbox.addEventListener("change", function () {
                    if (map.getLayer("parks-outline")) {
                        const visibility = parksCheckbox.checked ? 'visible' : 'none';
                        map.setLayoutProperty("parks-outline", "visibility", visibility);
                        console.log("Parks layer visibility set to", visibility);
                    } else {
                        console.log("Layer parks not found");
                    }
                    triggerPopupRefresh(map);
                });

                // Gliding layer toggle
                const glidingCheckbox = document.getElementById("toggleGliding");
                glidingCheckbox.addEventListener("change", function () {
                    if (map.getLayer("gliding-outline")) {
                        const visibility = glidingCheckbox.checked ? 'visible' : 'none';
                        map.setLayoutProperty("gliding-outline", "visibility", visibility);
                        console.log("Gliding layer visibility set to", visibility);
                    } else {
                        console.log("Layer gliding not found");
                    }
                    triggerPopupRefresh(map);
                });

                // LTA features toggle (filter on gliding layer)
                const ltaCheckbox = document.getElementById("toggleLTA");
                ltaCheckbox.addEventListener("change", function () {
                    if (map.getLayer("gliding-outline")) {
                        if (!ltaCheckbox.checked) {
                            map.setFilter("gliding-outline", ["!=", ["get", "customProperty"], "LTA"]);
                        } else {
                            map.setFilter("gliding-outline", null);
                        }
                    } else {
                        console.log("Layer gliding not found for filtering LTA features");
                    }
                    triggerPopupRefresh(map);
                });

                // Handler for filtering the other-fill and other-outline layers; add popup refresh.
                function updateOtherLayerFilter() {
                    let filter = ["all"];
                    if (!document.getElementById("toggleProhibited").checked) {
                        filter.push(["!=", ["get", "type"], "Prohibited"]);
                    }
                    if (!document.getElementById("toggleRestricted").checked) {
                        filter.push(["!=", ["get", "type"], "Restricted"]);
                    }
                    if (!document.getElementById("toggleDangerous").checked) {
                        filter.push(["!=", ["get", "type"], "Dangerous"]);
                    }
                    if (!document.getElementById("toggleABCD").checked) {
                        filter.push(["!=", ["get", "icaoClass"], "A"]);
                        filter.push(["!=", ["get", "icaoClass"], "B"]);
                        filter.push(["!=", ["get", "icaoClass"], "C"]);
                        filter.push(["!=", ["get", "icaoClass"], "D"]);
                    }
                    if (!document.getElementById("toggleEFG").checked) {
                        filter.push(["!=", ["get", "icaoClass"], "E"]);
                        filter.push(["!=", ["get", "icaoClass"], "F"]);
                        filter.push(["!=", ["get", "icaoClass"], "G"]);
                    }
                    if (!document.getElementById("toggleZSM").checked) {
                        filter.push(["!=", ["get", "type"], "ZSM"]);
                    }
                    if (!document.getElementById("toggleRMZ").checked) {
                        filter.push(["!=", ["get", "type"], "RMZ"]);
                    }
                    if (!document.getElementById("toggleTMZ").checked) {
                        filter.push(["!=", ["get", "type"], "TMZ"]);
                    }
                    if (!document.getElementById("toggleParaVoltige").checked) {
                        filter.push(["!=", ["get", "type"], "Para/voltige"]);
                    }
                    const finalFilter = filter.length > 1 ? filter : null;
                    // if (map.getLayer("other-fill")) {
                    //     map.setFilter("other-fill", finalFilter);
                    // }
                    if (map.getLayer("other-outline")) {
                        map.setFilter("other-outline", finalFilter);
                    }
                    console.log("Other layer filter updated:", finalFilter);
                    triggerPopupRefresh(map);
                }

                // Attach change event listeners to the other layer checkboxes.
                [
                    document.getElementById("toggleProhibited"),
                    document.getElementById("toggleRestricted"),
                    document.getElementById("toggleDangerous"),
                    document.getElementById("toggleABCD"),
                    document.getElementById("toggleEFG"),
                    document.getElementById("toggleZSM"),
                    document.getElementById("toggleRMZ"),
                    document.getElementById("toggleTMZ"),
                    document.getElementById("toggleParaVoltige")
                ].forEach(checkbox => {
                    checkbox.addEventListener("change", updateOtherLayerFilter);
                });

                // -----------------------------
                // Map click handler (inside #map) to open a new popup or, if already open, close it.
                // -----------------------------
                map.on('click', function (e) {
                    // Store the clicked location.
                    lastPopupLngLat = e.lngLat;

                    const existingPopup = document.querySelector('.popup-menu');
                    if (existingPopup) {
                        // Clicking on the map when a popup is open: remove it and clear highlight & marker.
                        existingPopup.remove();
                        clearHighlight(map);
                        lastPopupLngLat = null;
                        return;
                    }

                    // Create a marker at the clicked location.
                    if (popupMarker) {
                        popupMarker.remove();
                    }
                    popupMarker = new maplibregl.Marker({ color: 'red' })
                        .setLngLat(e.lngLat)
                        .addTo(map);

                    // Query features and apply filtering.
                    let currentPoint = map.project(lastPopupLngLat);
                    let features = map.queryRenderedFeatures(currentPoint, {
                        layers: ["SIV-fill", "gliding-fill", "parks-fill", "FIR-fill", "other-fill"]
                    });
                    features = filterMapFeatures(features);

                    // Create the popup (which internally uses buildPopupSection()).
                    createAirspacePopup(e, features, map);
                    console.log("Features at click (filtered):", features.map(f => f.properties));
                });

                /*
                  Add a listener to refresh the popup when zoom changes.
                  You can use 'zoomend' (fired when the zooming completes) or
                  'moveend' (if you want to catch pans as well).
                */
                map.on('zoomend', function () {
                    if (lastPopupLngLat) {
                        refreshAirspacePopup(map);
                    }
                });
            });

            map.on('error', function (e) {
                console.error("Map error:", e);
            });
        }

        console.log("Calling initializeApp");
        initializeApp();
    </script>
</body>

</html>