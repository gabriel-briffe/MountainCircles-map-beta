<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="/MountainCircles-map-beta/">
    <title>MountainCircles Map - Beta</title>
    <!-- Using jsDelivr instead of unpkg to avoid potential network errors on Windows -->
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; }
        #map { width: 100%; height: 100vh; }
        /* Simple style for the basemap switcher */
        #styleSwitcher {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        /* Container uses flex, aligning items in the center vertically */
        #polygonOpacityControl {
            position: absolute;
            top: 50px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
        }
        /* Make the button a flex container so its content centers */
        #polygonOpacityControl button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin-right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            min-height: 24px; /* ensures the button is at least 24px tall */
        }
        /* Force the Material Icons font with !important */
        .material-icons-round {
            font-family: 'Material Icons Round' !important;
            font-size: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            color: #000;
        }
        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- MAP DOCK (apple-dock style) --------------- */
        #mapDock {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            flex-direction: column;
            max-height: 100%;
            flex-wrap: wrap-reverse;
            gap: 10px;
            z-index: 1100;
        }

        /* -------------------------- */
        /* Slider Container (Dock Box) */
        /* -------------------------- */
        .dock-slider {
            width: 48px;       /* Same as other button width */
            height: 150px;     /* Give enough room for the rotated slider */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.8); /* Light mode: white-ish background */
            border-radius: 8px;
            padding: 8px;
            box-sizing: border-box;
        }

        /* Slider styling remains the same in landscape mode */
        #polygonOpacitySlider {
            width: 150px;  /* Length of the slider track */
            -webkit-transform: rotate(-90deg);
            -ms-transform: rotate(-90deg);
            transform: rotate(-90deg);
            -webkit-appearance: none; /* Remove default styling */
            background: transparent;  /* Needed for custom pseudo-elements */
        }

        /* Portrait mode: dock is horizontal, so the slider must be horizontal */
        @media (orientation: portrait) {
            #mapDock {
                position: fixed;
                top: 10px;
                left: 0;
                right: 0;
                width: 100%;
                padding: 0 0; /* Optional: Add some horizontal spacing */
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center; /* Center items in each row */
                gap: 10px;
                transform: translateY(0);
            }
            .dock-slider {
                /* Adjust container to have the same height as other buttons */
                width: 150px;
                height: 48px;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 8px;
                padding: 8px;
                box-sizing: border-box;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            /* Force the slider to be horizontal by resetting its rotation */
            .dock-slider #polygonOpacitySlider {
                -webkit-transform: rotate(0deg) !important;
                -ms-transform: rotate(0deg) !important;
                transform: rotate(0deg) !important;
                width: 100% !important;
            }
            /* Hide zoom buttons that aren't needed in portrait */
            #zoomInBtn,
            #zoomOutBtn {
                display: none;
            }
        }

        /* Dark mode adjustments: use a grey background similar to the buttons */
        @media (prefers-color-scheme: dark) {
            .dock-slider {
                background: rgba(20, 20, 20, 0.8);
            }
        }

        /* ===================== */
        /* Custom Slider Styling */
        /* ===================== */

        /* For Webkit Browsers (Chrome, Safari, Opera) */
        #polygonOpacitySlider::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            margin-top: -7px; /* Center the thumb on the track */
            cursor: pointer;
        }

        /* For Firefox */
        #polygonOpacitySlider::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* For IE */
        #polygonOpacitySlider::-ms-track {
            width: 100%;
            height: 6px;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }
        #polygonOpacitySlider::-ms-fill-lower {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-fill-upper {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* Dark mode adjustments: use a darker grey for the slider track */
        @media (prefers-color-scheme: dark) {
            #polygonOpacitySlider::-webkit-slider-runnable-track {
                background: #555;
            }
            #polygonOpacitySlider::-moz-range-track {
                background: #555;
            }
            #polygonOpacitySlider::-ms-fill-lower,
            #polygonOpacitySlider::-ms-fill-upper {
                background: #555;
            }
        }

        @media (pointer: coarse) {
            #zoomInBtn,
            #zoomOutBtn {
                display: none;
            }
        }

        /* Map Dock Buttons: Remove transition and hover effects */
        #mapDock button {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            outline: none;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: none;  /* Disabled transition for scaling and background changes */
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #mapDock button:hover {
            transform: none;   /* Disable zooming (scaling) */
            background: rgba(255, 255, 255, 0.8);  /* Keep same background */
        }

        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            #mapDock button {
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock button:hover {
                transform: none;   /* Disable zooming in dark mode as well */
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- POPUP MENU (centered on screen) --------------- */
        #popupMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 1200;
        }
        #popupMenu .popup-content {
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            max-height: 60%; /* Limit the height to 90% of the viewport height */
            overflow-y: auto; /* Add vertical scrolling if content overflows */
            position: relative;
            font-family: sans-serif;
            text-align: center;
            color: #000;
        }
        
        /* Config buttons container: centers buttons and adds gap with extra bottom margin */
        #popupMenu #configButtons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;  /* 5px gap between config buttons */
            margin-bottom: 15px;
        }

        /* Style for configuration buttons inside the popup menu */
        #popupMenu #configButtons button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;  /* fallback margin, in addition to the flex gap */
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        #popupMenu #configButtons button:hover {
            background: #ddd;
        }

        /* Style for the IGC file button; also centered and separated */
        #popupMenu button#igcFileButton {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #eee;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 15px;  /* extra top margin to separate from the config buttons */
            cursor: pointer;
        }
        #popupMenu button#igcFileButton:hover {
            background: #ddd;
        }

        /* Style for the close button in the popup menu using a Material Icon */
        #popupMenu .popup-content .close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #000;
        }

        /* Dark mode styling for the popup (like the dock) */
        @media (prefers-color-scheme: dark) {
            #popupMenu .popup-content {
                background: rgba(20, 20, 20, 0.9);
                color: #fff;
            }
            #popupMenu #configButtons button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu #configButtons button:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu button#igcFileButton {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu button#igcFileButton:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu .popup-content .close {
                color: #fff;
            }
        }

        /* ===== Spinner Styling ===== */
        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            display: none; /* Hidden by default */
        }
        .spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Common style for configuration buttons */
        .config-button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        .config-button:hover {
            background: #ddd;
        }

        @media (prefers-color-scheme: dark) {
            .config-button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            .config-button:hover {
                background: rgba(20, 20, 20, 1);
            }
        }

        .policy-section {
            margin-bottom: 20px;
        }
        
        .policy-section h3 {
            margin-bottom: 10px;
            text-align: center;
        }
        
        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .policy-section h3 {
                color: #fff;
            }
        }
    </style>
</head>
<body>
    <!-- Transparent Loading/Connection Message on Top of the Map -->
    <div id="loadingMessage" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 1000; background: rgba(255,255,255,0.8); padding: 10px 20px; border-radius: 3px; font-family: sans-serif; display: none;">
        Loading files, please wait...
    </div>

    <!-- Spinner for GeoJSON loading -->
    <div id="spinner">
        <div class="spinner"></div>
    </div>

    <div id="map"></div>

    <!-- Transparent Box on Bottom Left with Big Bold Text -->
    <div id="parametersBox" style="position: absolute; bottom: 10px; left: 10px; z-index: 1; background: rgba(255, 255, 255, 0.5); padding: 10px; border-radius: 5px; font-family: sans-serif; font-weight: bold; font-size: 24px; color: #000;">
        glide parameters
    </div>

    <!-- Map Dock: Controls always visible -->
    <div id="mapDock">
        <!-- Toggle Visibility for main layers -->
        <button title="Toggle Layer Visibility" id="toggleLayerButton">
            <span class="material-icons-round" id="visibilityIcon">visibility</span>
        </button>
        
        <!-- New Button to Toggle the Polygon Layer -->
        <button title="Toggle Polygon Layer" id="togglePolygonButton">
            <span class="material-icons-round" id="polygonVisibilityIcon">layers</span>
        </button>
        
        <!-- Slider wrapper for polygon opacity -->
        <div class="dock-slider">
            <input id="polygonOpacitySlider" type="range" min="0" max="0.5" step="0.01" value="0.1">
        </div>
        
        <!-- New Zoom Buttons replacing the text size buttons -->
        <button title="Zoom In" id="zoomInBtn">
            <span class="material-icons-round">zoom_in</span>
        </button>
        <button title="Zoom Out" id="zoomOutBtn">
            <span class="material-icons-round">zoom_out</span>
        </button>
        <button title="More Options" id="moreOptionsBtn">
            <span class="material-icons-round">menu</span>
        </button>
        <button title="Track Location" id="locationTrackingBtn">
            <span class="material-icons-round">my_location</span>
        </button>
    </div>

    <!-- Popup Menu: For controls not requiring constant map visibility -->
    <div id="popupMenu">
        <div class="popup-content">
            <h3>Text Size</h3>
            <!-- Text Size Controls moved from the dock to the top of the popup -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <button title="Increase Text Size" id="textIncreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_plus_1</span>
                </button>
                <button title="Decrease Text Size" id="textDecreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_minus_1</span>
                </button>
            </div>
            <button class="close" id="closePopupBtn">
                <span class="material-icons-round">close</span>
            </button>
            <h3>Select Glide ratio</h3>
            <div id="policyConfigs"></div>
            <!-- IGC File Control with Icon -->
            <button id="igcFileButton">
                <span class="material-icons-round">folder_open</span>
                <span>Open IGC File</span>
            </button>
            <h3>Warning</h3>
            <p>This is a new experimental tool. Problems will arise that have not been encountered before in the gliding community.</p>
            <p>I am not sure that 100m above ground is big enough a margin to be safe above the passes.</p>
            <p>Airspace is not taken into account. Downdrafts are not taken into account. Wind is not taken into account.</p>
            <p>The airfield list might not be accurate, some airfields might be unservicable or closed.</p>
            <p>Check on a real map that the indications make sense.</p>
            <p>Speak with the owner of the glider (your club's instructors for example) about using this tool. They might foresee problems that you and the author have not anticipated and save your life.</p>
            <p>The author is not liable for any damage or injury that might occur by using this tool.</p>
            <!-- Hidden file input triggered by the IGC file button -->
            <input type="file" id="igcFileInput" accept="*/*" style="display: none;">
        </div>
    </div>

    <script>

        const customStyle = {
            "version": 8,
            "name": "Custom Map",
            "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
            "sources": {
                "custom-tiles": {
                    "type": "raster",
                    "tiles": [
                        "./tiles/{z}/{x}/{y}.png"  // Relative path to your tiles folder on GitHub Pages
                    ],
                    "tileSize": 256,
                    "maxzoom": 12,  // This ensures that even if you zoom past level 12, the map uses these tiles.
                    "attribution": "Map data Â© OpenStreetMap contributors + Alos topographic data"
                }
            },
            "layers": [
                {
                    "id": "custom-tiles",
                    "type": "raster",
                    "source": "custom-tiles",
                    "minzoom": 0   // Remove maxzoom here so the layer remains visible at higher zooms
                }
            ]
        };
        const policies = {
            'alps': [
                '10-100-250-4200',
                '20-100-250-4200',
                '25-100-250-4200',
                '30-100-250-4200',
            ],
            'West_alps_with_fields': [
                '10-100-250-4200',
                '20-100-250-4200',
                '25-100-250-4200',
                '30-100-250-4200',
            ]
        };


        // Update the currentConfig to include policy
        let currentPolicy = 'alps';  // Default policy
        let currentConfig = currentPolicy + '/' + '20-100-250-4200';  // Default config with policy prefix

        // Create policy sections and their config buttons
        const policyConfigsContainer = document.getElementById('policyConfigs');
        
        Object.entries(policies).forEach(([policy, configs]) => {
            // Create section for this policy
            const policySection = document.createElement('div');
            policySection.className = 'policy-section';
            
            // Add policy header
            const policyHeader = document.createElement('h3');
            policyHeader.textContent = policy;
            policySection.appendChild(policyHeader);
            
            // Create container for this policy's config buttons
            const configButtonsContainer = document.createElement('div');
            configButtonsContainer.className = 'config-buttons';
            configButtonsContainer.style.display = 'flex';
            configButtonsContainer.style.flexWrap = 'wrap';
            configButtonsContainer.style.justifyContent = 'center';
            configButtonsContainer.style.gap = '5px';
            configButtonsContainer.style.marginBottom = '15px';
            
            // Add config buttons for this policy
            configs.forEach(cfg => {
                const btn = document.createElement('button');
                btn.textContent = cfg.split('-')[0];  // Use first part as button label
                btn.className = 'config-button';
                btn.addEventListener('click', () => {
                    const newConfig = policy + '/' + cfg;
                    switchConfig(newConfig);
                    document.getElementById('popupMenu').style.display = "none";
                    console.log("Switched to configuration: " + newConfig);
                });
                configButtonsContainer.appendChild(btn);
            });
            
            policySection.appendChild(configButtonsContainer);
            policyConfigsContainer.appendChild(policySection);
        });

        // Update the switchConfig function to handle policy prefixes
        function switchConfig(cfg) {
            removeDynamicLayers();
            removeGeoJSONLayers();
            updateParametersBox(cfg.split('/')[1]);  // Pass only the config part, not the policy
            currentConfig = cfg;
            currentPolicy = cfg.split('/')[0];
            addGeoJSONLayers();
        }

        // Update addGeoJSONLayers to use the policy name in file paths
        function addGeoJSONLayers() {
            const configParts = currentConfig.split('/');
            const configPrefix = configParts[1].split('-').slice(0, 3).join('-');
            const policyName = configParts[0]; // Convert policy name to lowercase for filenames

            if (!map.getSource('geojson-data')) {
                map.addSource('geojson-data', {
                    type: 'geojson',
                    data: currentConfig + '/aa_' + policyName + '_' + configPrefix + '.geojson'
                });
            } else {
                map.getSource('geojson-data').setData(currentConfig + '/aa_' + policyName + '_' + configPrefix + '.geojson');
            }
            
            if (!map.getSource('polygons')) {
                map.addSource('polygons', {
                    type: 'geojson',
                    data: currentConfig + '/aa_' + policyName + '_' + configPrefix + '_sectors1.geojson'
                });
            } else {
                map.getSource('polygons').setData(currentConfig + '/aa_' + policyName + '_' + configPrefix + '_sectors1.geojson');
            }
            
            // ---------------------------------------------------------------------
            // First load the polygon layer so that it renders underneath subsequent layers.
            if (!map.getLayer('polygons-layer')) {
                map.addLayer({
                    id: 'polygons-layer',
                    type: 'fill',
                    source: 'polygons',
                    paint: {
                        'fill-color': [
                            "match",
                            ["get", "color_id"],
                            0, "#0000FF",
                            1, "#FF00FF",
                            2, "#FFFF00",
                            3, "#00FFFF",
                            4, "#00FF00",
                            5, "#FF0000",
                            6, "#FFA500",
                            "#000000"
                        ],
                        'fill-opacity': 0.1
                    }
                });
            }
            
            // ---------------------------------------------------------------------
            // Add non-label layers (features) next.
            if (!map.getLayer('linestrings-layer')) {
                map.addLayer({
                    id: 'linestrings-layer',
                    type: 'line',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });
            }
            
            if (!map.getLayer('points-layer')) {
                map.addLayer({
                    id: 'points-layer',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#ff0000',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#fff'
                    }
                });
            }
            
            if (!map.getLayer('points-layer-clickable')) {
                map.addLayer({
                    id: 'points-layer-clickable',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 20,
                        'circle-color': '#000000',
                        'circle-opacity': 0
                    }
                });
            }
            
            // ---------------------------------------------------------------------
            // Now add the label layers so they always render on top.
            if (!map.getLayer('linestrings-labels')) {
                map.addLayer({
                    id: 'linestrings-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
            
            if (!map.getLayer('points-labels')) {
                map.addLayer({
                    id: 'points-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 7,
                    filter: ['==', '$type', 'Point'],
                    layout: {
                        'text-field': '{name}',
                        'text-size': baseTextSize + 5,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0.8, 0.8],
                        'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
                        'text-radial-offset': 0.8,
                        'symbol-spacing': 20
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
        }
        
        // Declare map in the global scope.
        let map;
        
        // Helper to update the parameters box text based on the config folder.
        function updateParametersBox(cfg) {
            const parts = cfg.split('-'); // e.g. ["20", "100", "250", "4200"]
            if (parts.length >= 3) {
                const labelText = "L/D " + parts[0] + "-ground " + parts[1] + "m-circuit " + parts[2] + "m";
                document.getElementById('parametersBox').textContent = labelText;
            }
        }
        
        // Call updateParametersBox at startup.
        updateParametersBox(currentConfig);
        
        // Function to remove static GeoJSON layers and sources.
        function removeGeoJSONLayers() {
            const layersToRemove = [
                'linestrings-layer',
                'linestrings-labels',
                'points-layer',
                'points-labels',
                'points-layer-clickable',
                'polygons-layer'
            ];
            layersToRemove.forEach(id => {
                if (map.getLayer(id)) {
                    map.removeLayer(id);
                }
            });
            const sourcesToRemove = ['geojson-data', 'polygons'];
            sourcesToRemove.forEach(id => {
                if (map.getSource(id)) {
                    map.removeSource(id);
                }
            });
        }
        
        // Function to remove dynamic layers added when clicking a point.
        function removeDynamicLayers() {
            // Remove dynamic layers (their id starts with "dynamic-lines-")
            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if(layer.id.startsWith('dynamic-lines-')) {
                    if(map.getLayer(layer.id)) { 
                        map.removeLayer(layer.id);
                    }
                }
            });
            
            // Remove the dynamic sources; we iterate over all source names.
            const sourceIds = Object.keys(map.style.sourceCaches);
            sourceIds.forEach(sourceId => {
                if(sourceId.startsWith('dynamic-lines-')) {
                    if(map.getSource(sourceId)) { 
                        map.removeSource(sourceId);
                    }
                }
            });
        }
        
        // Global variable for the base text size that all labels will use.
        let baseTextSize = 14; // Default value; adjust as desired

        // Function that iterates over the map's layers and updates the 'text-size' of any symbol layer
        // If the layer ID is "points-labels", we add 5 to baseTextSize.
        function updateAllLabelSizes() {
            // Iterate over all layers in the current map style.
            map.getStyle().layers.forEach(layer => {
                if (layer.type === 'symbol' && layer.layout && layer.layout["text-size"] !== undefined) {
                    // For the points labels, use baseTextSize + 5.
                    if (layer.id === 'points-labels') {
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize + 5);
                    } else {
                        // For all other symbol layers (lines labels, dynamic labels, altitude labels, etc.), use baseTextSize.
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize);
                    }
                }
            });
        }

        // Updated dynamic point click handler to use the current config folder.
        function handlePointClick(e) {
            console.log("Point clicked event:", e);
            if (!e.features || !e.features.length) return;
        
            const feature = e.features[0];
            if (!feature.properties || !feature.properties.filename) {
                console.warn("Clicked feature missing 'filename' property:", feature);
                return;
            }

            // Build the file path and dynamic layer IDs.
            const filePath = currentConfig + "/" + feature.properties.filename;
            const dynamicLayerId = 'dynamic-lines-' + currentConfig + '-' + feature.properties.filename;
            const dynamicSourceId = dynamicLayerId + '-source';
            const dynamicLabelId = dynamicLayerId + '-labels';

            // -- Hide any dynamic layers (and their corresponding labels) that are NOT the one for this point --
            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if (layer.id.startsWith('dynamic-lines-') && layer.id !== dynamicLayerId) {
                    if (map.getLayer(layer.id)) {
                        map.setLayoutProperty(layer.id, 'visibility', 'none');
                    }
                    // Assume that label layers have the suffix "-labels" attached to the dynamic layer ID.
                    const otherLabelId = layer.id + '-labels';
                    if (map.getLayer(otherLabelId)) {
                        map.setLayoutProperty(otherLabelId, 'visibility', 'none');
                    }
                }
            });

            // -- If the dynamic layer for this point exists, toggle its visibility. --
            if (map.getLayer(dynamicLayerId)) {
                let currentVisibility = map.getLayoutProperty(dynamicLayerId, 'visibility') || 'visible';
                if (currentVisibility === 'visible') {
                    // If clicking the same point again: hide the dynamic layer and restore the main linestring layer.
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'none');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'visible');
                    }
                } else {
                    // If the dynamic layer exists but is hidden, show it and hide the main linestring layer.
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'visible');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                    }
                }
            } else {
                // -- Dynamic layer not yet created --
                // Hide the main linestring layer when showing a dynamic one.
                if (map.getLayer('linestrings-layer')) {
                    map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                }
                if (map.getLayer('linestrings-labels')) {
                    map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                }
                console.log("Adding dynamic layer for:", filePath);
                // Add the dynamic source.
                map.addSource(dynamicSourceId, {
                    type: 'geojson',
                    data: filePath
                });

                // Add the dynamic line layer.
                map.addLayer({
                    id: dynamicLayerId,
                    type: 'line',
                    source: dynamicSourceId,
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });

                // Add the corresponding dynamic label layer.
                map.addLayer({
                    id: dynamicLabelId,
                    type: 'symbol',
                    source: dynamicSourceId,
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }

            // Update the main linestring visibility icon based on current state.
            const mainVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
            document.getElementById('visibilityIcon').textContent = mainVisibility === 'visible' ? 'visibility' : 'visibility_off';
        }
        
        // Now that our helper functions and event listeners are set up,
        // initialize the map. (Ensure any variables like currentStyle are defined or adjust as needed.)
        const currentStyle = customStyle ;
        
        map = new maplibregl.Map({
            container: 'map',
            style: currentStyle,
            bounds: [[4.9698169, 43.6088902], [13.696105, 47.5644488]],
            maxBounds: [[4.57526, 43.45699], [13.96581, 47.98810]],
            maxZoom: 16,  // The user can zoom in further; level 12 tiles will be overscaled
            fitBoundsOptions: {
                padding: 50,
                maxZoom: 12,  // fitBounds will not zoom past level 12 unless you override this
                duration: 1000
            },
            attributionControl: false,
            renderWorldCopies: false
        });
        
        // --- GeoJSON Spinner Logic with Debounce ---
        // This Set will track only GeoJSON sources that are still loading.
        var loadingGeojsonSources = new Set();
        // Timer to debounce spinner display
        var spinnerTimeout = null;

        map.on('sourcedata', function(e) {
            // Only process events for sources (not individual tiles) and where the source type is "geojson".
            if (e.dataType !== 'source' || !e.source || e.source.type !== 'geojson') {
                return;
            }
            if (!e.isSourceLoaded) {
                loadingGeojsonSources.add(e.sourceId);
            } else {
                loadingGeojsonSources.delete(e.sourceId);
            }
            
            // If any GeoJSON sources are still loading, set a timer to show the spinner
            if (loadingGeojsonSources.size > 0) {
                if (!spinnerTimeout) {
                    spinnerTimeout = setTimeout(() => {
                        document.getElementById('spinner').style.display = 'block';
                    }, 200);
                }
            } else {
                // All GeoJSON sources are loaded: clear the timer and hide the spinner
                clearTimeout(spinnerTimeout);
                spinnerTimeout = null;
                document.getElementById('spinner').style.display = 'none';
            }
        });
        
        // Attach layers and events once the map has fully loaded.
        map.on('load', () => {
            addGeoJSONLayers();
            
            // First create and load the arrow icon
            const arrowImage = new Image(20, 20);
            arrowImage.onload = () => {
                // Only add the source and layer after the icon is loaded
                map.addImage('arrow', arrowImage);
                
                // Then add the location marker source
                map.addSource('location-marker', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [0, 0]
                        },
                        properties: {
                            bearing: 0
                        }
                    }
                });

                // Finally add the location marker layer
                map.addLayer({
                    id: 'location-marker',
                    type: 'symbol',
                    source: 'location-marker',
                    layout: {
                        'icon-image': 'arrow',
                        'icon-size': 1,
                        'icon-rotate': ['get', 'bearing'],
                        'icon-rotation-alignment': 'map',
                        'icon-allow-overlap': true,
                        'icon-ignore-placement': true
                    }
                });
            };
            arrowImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAGHSURBVDiNrdS/S1ZhFMfx93nkXgdFcHBoEERoKYKWEBqiP6GhKYKWlqDVQRqCoCFoCAqaGhqiJQiCpqYgaAhavF4vvF4vkuW9t+E5cLk8z/srn+mc7/mec57znO85/EfUap1eRLyNiG8RsRQRSxHxNSLeRES31vPfiIjDEbEcmxER0xHR2G2g0RjeiYiXEXEqIqYjot3oNGcaEXE6Il5FxN2IaP0VrNW6ExFxMyL2j9PZiLgVEbO7Ao2GuxExN0lnI+JeRByYCIyIyxExvxvQaDjvR8TlsWCtdjgiHkTEob8FjYbzYURcGAFrtXZEPImIo/8KGg3nk4g4NwK22zsi4llEnNgr0Gg4n0fE2WGw3Z6OiJcRcWqvQaPhfBURp4fATmc2Il5HxJn/BRoN57uIONnvdLszFxFvI+L8XoNGw/khIo73O93uLETEh4i4+K9Ao+H8FBHH+p3FiPgcEVci4p9vYa3WvxwRnyLiWkR8jIgrEfHov0P+K74DcFbuDyWw7ggAAAAASUVORK5CYII=';
            
            // Rest of the map.on('load') code...
            if (map.getLayer('points-layer-clickable')) {
                map.on('click', 'points-layer-clickable', handlePointClick);
            }
            if (navigator.onLine) {
                map.once('idle', hideLoadingMessage);
            }
        });
        

        // Function to show the loading message with a given text.
        function showLoadingMessage(text) {
            const messageDiv = document.getElementById('loadingMessage');
            messageDiv.textContent = text;
            messageDiv.style.display = "block";
        }

        // Function to hide the loading message.
        function hideLoadingMessage() {
            document.getElementById('loadingMessage').style.display = "none";
        }

        // --- Connection Message Logic ---
        function updateConnectionMessage() {
            const messageDiv = document.getElementById('loadingMessage');
            if (!navigator.onLine) {
                messageDiv.textContent = "No internet connection. Please connect to the internet.";
                messageDiv.style.display = "block";
            } else {
                messageDiv.style.display = "none";
            }
        }

        updateConnectionMessage();

        window.addEventListener('offline', updateConnectionMessage);
        window.addEventListener('online', updateConnectionMessage);

        const polygonOpacitySlider = document.getElementById('polygonOpacitySlider');
        polygonOpacitySlider.addEventListener('input', function() {
            const opacity = parseFloat(this.value);
            if (map.getLayer('polygons-layer')) {
                map.setPaintProperty('polygons-layer', 'fill-opacity', opacity);
            }
        });

        // Toggle the popup menu
        const popupMenu = document.getElementById('popupMenu');
        document.getElementById('moreOptionsBtn').addEventListener('click', () => {
            popupMenu.style.display = "flex";
        });
        document.getElementById('closePopupBtn').addEventListener('click', () => {
            popupMenu.style.display = "none";
        });

        // Close popup when clicking outside the popup content
        popupMenu.addEventListener('click', (e) => {
            if(e.target === popupMenu) {
                popupMenu.style.display = "none";
            }
        });

        // --- IGC File Functionality (ported from production) ---

        // Function to parse IGC file and convert to GeoJSON
        function igcToGeoJSON(igcContent) {
            // Parse IGC file content
            const lines = igcContent.split('\n');
            const coordinates = [];
            let metadata = {};

            for (const line of lines) {
                // Handle B records (position fixes)
                if (line.startsWith('B')) {
                    try {
                        // Extract time (HHMMSS)
                        const time = line.substring(1, 7);
                        // Extract latitude (DDMMmmmN/S)
                        const latRaw = line.substring(7, 15);
                        const latDeg = parseInt(latRaw.substring(0, 2));
                        const latMin = parseFloat(latRaw.substring(2, 7)) / 1000;
                        const latDir = latRaw.substring(7, 8);
                        // Extract longitude (DDDMMmmmE/W)
                        const lonRaw = line.substring(15, 24);
                        const lonDeg = parseInt(lonRaw.substring(0, 3));
                        const lonMin = parseFloat(lonRaw.substring(3, 8)) / 1000;
                        const lonDir = lonRaw.substring(8, 9);
                        // Extract altitude (AAAAA)
                        const altPressure = parseInt(line.substring(25, 30));
                        const altGNSS = parseInt(line.substring(30, 35));

                        // Convert latitude to decimal
                        let latitude = latDeg + (latMin / 60);
                        if (latDir === 'S') latitude = -latitude;

                        // Convert longitude to decimal
                        let longitude = lonDeg + (lonMin / 60);
                        if (lonDir === 'W') longitude = -longitude;

                        // Use GNSS altitude if available, otherwise use pressure altitude
                        const altitude = altPressure > 0 ? altPressure : altGNSS;

                        coordinates.push([longitude, latitude, altitude]);
                    } catch (error) {
                        console.warn('Error parsing B record:', line, error);
                    }
                }
                // Handle H records (header/metadata)
                else if (line.startsWith('H')) {
                    try {
                        const headerType = line.substring(1, 5);
                        const headerValue = line.substring(5).trim();

                        if (headerType.startsWith('FDT')) metadata.date = headerValue;
                        if (headerType.startsWith('FPL')) metadata.pilot = headerValue;
                        if (headerType.startsWith('FGT')) metadata.gliderType = headerValue;
                        if (headerType.startsWith('FGI')) metadata.gliderID = headerValue;
                    } catch (error) {
                        console.warn('Error parsing H record:', line, error);
                    }
                }
            }

            // Create GeoJSON object
            const geojson = {
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    },
                    properties: {
                        ...metadata,
                        sourceFormat: 'IGC',
                        coordinateProperties: {
                            altitudes: coordinates.map(coord => coord[2])
                        }
                    }
                }]
            };

            return geojson;
        }

        // Replace your current handleFileSelect with the following enhanced version.
        // It reads the IGC file, converts it to GeoJSON, adds a new line layer (with blue color),
        // computes its bounding box, recenters the map, and adds altitude labels.
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Close the popup menu after a file has been selected.
            document.getElementById('popupMenu').style.display = "none";
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const igcContent = e.target.result;
                const geojsonData = igcToGeoJSON(igcContent);
                console.log('Converted IGC to GeoJSON:', geojsonData);
                
                // Generate a dynamic layer ID from the file name (strip non-alphanumeric characters)
                const baseLayerId = 'igc-layer-' + file.name.replace(/\W/g, '');
                let layerId = baseLayerId;
                // If a layer with the same ID exists, append a timestamp
                if (map.getLayer(layerId)) {
                    layerId = baseLayerId + '-' + Date.now();
                }
                const sourceId = layerId + '-source';
                
                // Add a new source and corresponding line layer to the map for the IGC flight track
                map.addSource(sourceId, {
                    type: 'geojson',
                    data: geojsonData
                });
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#0000FF',
                        'line-width': 2
                    }
                });
                
                // Compute the bounding box of the IGC track based on its coordinates
                const coords = geojsonData.features[0].geometry.coordinates;
                let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
                coords.forEach(coord => {
                    const [lng, lat] = coord;
                    if (lng < minLng) minLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lng > maxLng) maxLng = lng;
                    if (lat > maxLat) maxLat = lat;
                });
                const bounds = [[minLng, minLat], [maxLng, maxLat]];
                
                // Recenter the map so that the IGC track fits within the view
                map.fitBounds(bounds, {
                    padding: 50,
                    maxZoom: 14,
                    duration: 1000
                });
                
                // Create altitude point features based on each vertex of the IGC LineString.
                const altPoints = {
                    type: 'FeatureCollection',
                    features: coords.map(coord => ({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [coord[0], coord[1]]
                        },
                        properties: {
                            altitude: coord[2]
                        }
                    }))
                };

                // Add a new source for the altitude labels
                const altSourceId = layerId + '-altitudes-source';
                map.addSource(altSourceId, {
                    type: 'geojson',
                    data: altPoints
                });

                // Add a symbol layer to display the altitude at each point (visible for zoom > 9)
                map.addLayer({
                    id: layerId + '-altitudes',
                    type: 'symbol',
                    source: altSourceId,
                    minzoom: 9,
                    layout: {
                        'text-field': '{altitude}',
                        'text-size': baseTextSize, // Use the base text size for altitude labels
                        'text-offset': [0, -0.5]
                    },
                    paint: {
                        'text-color': '#0000FF',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            };
            reader.readAsText(file);
        }

        // Wire up the IGC file button (in your popup menu) and file input
        document.getElementById('igcFileButton').addEventListener('click', function() {
            document.getElementById('igcFileInput').click();
            this.blur(); // Remove focus so the button doesn't stay highlighted.
        });
        document.getElementById('igcFileInput').addEventListener('change', handleFileSelect);

        // Toggle layer visibility for main linestrings layers and their labels
        document.getElementById('toggleLayerButton').addEventListener('click', () => {
            // Only include linestrings layers and labels in the toggle action.
            const layerIds = ['linestrings-layer', 'linestrings-labels'];
            // Determine the new visibility based on the current state of the "linestrings-layer".
            let newVisibility = 'visible';
            if (map.getLayer('linestrings-layer')) {
                const currentVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
                newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            }
            // Toggle the visibility of the specified layers.
            layerIds.forEach(id => {
                if (map.getLayer(id)) {
                    map.setLayoutProperty(id, 'visibility', newVisibility);
                }
            });
            // Update the icon text accordingly.
            document.getElementById('visibilityIcon').textContent = newVisibility === 'visible' ? 'visibility' : 'visibility_off';
        });
        // Zoom Button Event Listeners (newly added)
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            map.zoomIn();
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            map.zoomOut();
        });

        // Text Size Control Event Listeners (moved to the popup)
        document.getElementById('textDecreaseBtn').addEventListener('click', () => {
            baseTextSize = Math.max(1, baseTextSize - 1);
            updateAllLabelSizes();
        });

        // Increase Text Size Button event listener
        document.getElementById('textIncreaseBtn').addEventListener('click', () => {
            baseTextSize += 1;
            updateAllLabelSizes();
        });

        // Toggle the polygon layer visibility
        document.getElementById('togglePolygonButton').addEventListener('click', () => {
            const polygonLayerId = 'polygons-layer';
            // Get current visibility, assume "visible" if not explicitly set.
            let currentVisibility = map.getLayoutProperty(polygonLayerId, 'visibility') || 'visible';
            // Toggle visibility.
            let newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            map.setLayoutProperty(polygonLayerId, 'visibility', newVisibility);
            // Update the icon accordingly (using "layers" for visible and "layers_clear" for hidden).
            document.getElementById('polygonVisibilityIcon').textContent = newVisibility === 'visible' ? 'layers' : 'layers_clear';
        });

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/MountainCircles-map-beta/sw.js')
                .then(function(registration) {
                    console.log('Service Worker registered with scope:', registration.scope);
                })
                .catch(function(error) {
                    console.error('Service Worker registration failed:', error);
                });
        }

        // Keep track of previous position to calculate bearing
        let previousPosition = null;

        // Function to calculate bearing between two points
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const toRad = (deg) => deg * Math.PI / 180;
            const toDeg = (rad) => rad * 180 / Math.PI;
            
            const dLon = toRad(lon2 - lon1);
            const lat1Rad = toRad(lat1);
            const lat2Rad = toRad(lat2);
            
            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                     Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
            
            let bearing = toDeg(Math.atan2(y, x));
            return (bearing + 360) % 360;
        }

        // Function to update location and calculate bearing from movement
        function updateLocation(position) {
            console.log('Updating location:', position.coords);
            if (!map.getSource('location-marker')) {
                console.warn('Location marker source not found');
                return;
            }
            
            const coords = [position.coords.longitude, position.coords.latitude];
            let bearing = 0;
            
            // Calculate bearing if we have a previous position
            if (previousPosition) {
                bearing = calculateBearing(
                    previousPosition.coords.latitude,
                    previousPosition.coords.longitude,
                    position.coords.latitude,
                    position.coords.longitude
                );
                console.log('Calculated bearing:', bearing);
            }
            
            // Only update bearing if we're moving (speed > 1 m/s)
            if (position.coords.speed && position.coords.speed > 1) {
                // Update the marker position and bearing
                map.getSource('location-marker').setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coords
                    },
                    properties: {
                        bearing: bearing
                    }
                });
            } else {
                // Just update position if not moving
                map.getSource('location-marker').setData({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: coords
                    },
                    properties: {
                        bearing: bearing
                    }
                });
            }
            
            // Center map on user's location
            // map.easeTo({
            //     center: coords,
            //     zoom: map.getZoom()
            // });
            
            // Store current position for next update
            previousPosition = position;
        }

        let watchId = null;  // Store the watch ID to stop tracking when needed

        // Function to start location tracking
        function startLocationTracking() {
            if (!watchId && 'geolocation' in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 5000
                };
                
                watchId = navigator.geolocation.watchPosition(
                    updateLocation,
                    (error) => {
                        console.error('Error getting location:', error);
                    },
                    options
                );
                
                // Update button icon to show active tracking
                document.getElementById('locationTrackingBtn').querySelector('.material-icons-round').textContent = 'gps_fixed';
            }
        }

        // Function to stop location tracking
        function stopLocationTracking() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                
                // Update button icon to show tracking is off
                document.getElementById('locationTrackingBtn').querySelector('.material-icons-round').textContent = 'my_location';
                
                // Clear the marker from the map
                if (map.getSource('location-marker')) {
                    map.getSource('location-marker').setData({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [0, 0]
                        },
                        properties: {
                            bearing: 0
                        }
                    });
                }
            }
        }

        // Toggle location tracking when the button is clicked
        document.getElementById('locationTrackingBtn').addEventListener('click', () => {
            if (watchId) {
                stopLocationTracking();
            } else {
                startLocationTracking();
            }
        });

    </script>
</body>
</html>