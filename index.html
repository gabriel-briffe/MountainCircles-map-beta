<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="/MountainCircles-map-beta/">
    <title>MountainCircles Map - Beta</title>
    <!-- Using jsDelivr instead of unpkg to avoid potential network errors on Windows -->
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="MC Map">
    <meta name="theme-color" content="#000000">
    <style>
        body { margin: 0; padding: 0; }
        #map { width: 100%; height: 100vh; }
        /* Simple style for the basemap switcher */
        #styleSwitcher {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        /* Container uses flex, aligning items in the center vertically */
        #polygonOpacityControl {
            position: absolute;
            top: 50px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
        }
        /* Make the button a flex container so its content centers */
        #polygonOpacityControl button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin-right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            min-height: 24px; /* ensures the button is at least 24px tall */
        }
        /* Force the Material Icons font with !important */
        .material-icons-round {
            font-family: 'Material Icons Round' !important;
            font-size: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            color: #000;
        }
        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- MAP DOCK (apple-dock style) --------------- */
        #mapDock {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            flex-direction: column;
            max-height: 100%;
            flex-wrap: wrap-reverse;
            gap: 10px;
            z-index: 1100;
        }

        /* -------------------------- */
        /* Slider Container (Dock Box) */
        /* -------------------------- */
        .dock-slider {
            width: 48px;       /* Same as other button width */
            height: 150px;     /* Give enough room for the rotated slider */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.8); /* Light mode: white-ish background */
            border-radius: 8px;
            padding: 8px;
            box-sizing: border-box;
        }

        /* Slider styling remains the same in landscape mode */
        #polygonOpacitySlider {
            width: 150px;  /* Length of the slider track */
            -webkit-transform: rotate(-90deg);
            -ms-transform: rotate(-90deg);
            transform: rotate(-90deg);
            -webkit-appearance: none; /* Remove default styling */
            background: transparent;  /* Needed for custom pseudo-elements */
        }

        /* Portrait mode: dock is horizontal, so the slider must be horizontal */
        @media (orientation: portrait) {
            #mapDock {
                position: fixed;
                top: 10px;
                left: 0;
                right: 0;
                width: 100%;
                padding: 0 0; /* Optional: Add some horizontal spacing */
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center; /* Center items in each row */
                gap: 10px;
                transform: translateY(0);
            }
            .dock-slider {
                /* Adjust container to have the same height as other buttons */
                width: 150px;
                height: 48px;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 8px;
                padding: 8px;
                box-sizing: border-box;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            /* Force the slider to be horizontal by resetting its rotation */
            .dock-slider #polygonOpacitySlider {
                -webkit-transform: rotate(0deg) !important;
                -ms-transform: rotate(0deg) !important;
                transform: rotate(0deg) !important;
                width: 100% !important;
            }
        }

        /* Dark mode adjustments: use a grey background similar to the buttons */
        @media (prefers-color-scheme: dark) {
            .dock-slider {
                background: rgba(20, 20, 20, 0.8);
            }
        }

        /* ===================== */
        /* Custom Slider Styling */
        /* ===================== */

        /* For Webkit Browsers (Chrome, Safari, Opera) */
        #polygonOpacitySlider::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            margin-top: -7px; /* Center the thumb on the track */
            cursor: pointer;
        }

        /* For Firefox */
        #polygonOpacitySlider::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* For IE */
        #polygonOpacitySlider::-ms-track {
            width: 100%;
            height: 6px;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }
        #polygonOpacitySlider::-ms-fill-lower {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-fill-upper {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* Dark mode adjustments: use a darker grey for the slider track */
        @media (prefers-color-scheme: dark) {
            #polygonOpacitySlider::-webkit-slider-runnable-track {
                background: #555;
            }
            #polygonOpacitySlider::-moz-range-track {
                background: #555;
            }
            #polygonOpacitySlider::-ms-fill-lower,
            #polygonOpacitySlider::-ms-fill-upper {
                background: #555;
            }
        }


        /* Map Dock Buttons: Remove transition and hover effects */
        #mapDock button {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            outline: none;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: none;  /* Disabled transition for scaling and background changes */
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #mapDock button:hover {
            transform: none;   /* Disable zooming (scaling) */
            background: rgba(255, 255, 255, 0.8);  /* Keep same background */
        }

        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            #mapDock button {
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock button:hover {
                transform: none;   /* Disable zooming in dark mode as well */
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- POPUP MENU (centered on screen) --------------- */
        #popupMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.2);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 1200;
        }
        #popupMenu .popup-content {
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            max-height: 60%; /* Limit the height to 90% of the viewport height */
            overflow-y: auto; /* Add vertical scrolling if content overflows */
            position: relative;
            font-family: sans-serif;
            text-align: center;
            color: #000;
        }
        
        /* Config buttons container: centers buttons and adds gap with extra bottom margin */
        #popupMenu #configButtons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;  /* 5px gap between config buttons */
            margin-bottom: 15px;
        }

        /* Style for configuration buttons inside the popup menu */
        #popupMenu #configButtons button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;  /* fallback margin, in addition to the flex gap */
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        #popupMenu #configButtons button:hover {
            background: #ddd;
        }

        /* Style for the IGC file button; also centered and separated */
        #popupMenu button#igcFileButton {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #eee;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 15px;  /* extra top margin to separate from the config buttons */
            cursor: pointer;
        }
        #popupMenu button#igcFileButton:hover {
            background: #ddd;
        }

        /* Style for the close button in the popup menu using a Material Icon */
        #popupMenu .popup-content .close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #000;
        }

        /* Dark mode styling for the popup (like the dock) */
        @media (prefers-color-scheme: dark) {
            #popupMenu .popup-content {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu #configButtons button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu #configButtons button:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu button#igcFileButton {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu button#igcFileButton:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu .popup-content .close {
                color: #fff;
            }
        }

        /* ===== Spinner Styling ===== */
        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            display: none; /* Hidden by default */
        }
        .spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Common style for configuration buttons */
        .config-button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        .config-button:hover {
            background: #ddd;
        }

        @media (prefers-color-scheme: dark) {
            .config-button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            .config-button:hover {
                background: rgba(20, 20, 20, 1);
            }
        }

        .policy-section {
            margin-bottom: 20px;
        }
        
        .policy-section h3 {
            margin-bottom: 10px;
            text-align: center;
        }
        
        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .policy-section h3 {
                color: #fff;
            }
        }

        /* Style for layer toggle buttons */
        #peaksToggleBtn, #passesToggleBtn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
        }

        #peaksToggleBtn .material-icons-round,
        #passesToggleBtn .material-icons-round {
            font-size: 20px;
        }

        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            #peaksToggleBtn, #passesToggleBtn {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #peaksToggleBtn:hover, #passesToggleBtn:hover {
                background: rgba(20, 20, 20, 1);
            }
        }

        /* Update the CSS for the cache button */
        #cacheCurrentConfigBtn {
            transition: border 0.3s, box-shadow 0.3s;
            border: none;
            box-shadow: none;
            padding: 8px 12px;
            border-radius: 4px;
            position: relative; /* Ensure border works correctly */
            box-sizing: border-box; /* Include border in element size */
        }

        /* Style for cached configuration buttons */
        .cached-config {
            border: 2px solid #4CAF50; /* Green border */
        }

        /* Add to your existing CSS */
        #cacheProgress {
            display: none;
            flex-direction: column;
            width: 100%;
            align-items: center;
            margin-top: 10px;
        }

        .progress-bar-container {
            width: 80%;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <!-- Spinner for GeoJSON loading -->
    <div id="spinner">
        <div class="spinner"></div>
    </div>

    <div id="map"></div>

    <!-- Transparent Box on Bottom Left with Big Bold Text -->
    <div id="parametersBox" style="position: absolute; bottom: 10px; left: 10px; z-index: 1; background: rgba(255, 255, 255, 0.5); padding: 10px; border-radius: 5px; font-family: sans-serif; font-weight: bold; font-size: 24px; color: #000;">
        glide parameters
    </div>

    <!-- Map Dock: Controls always visible -->
    <div id="mapDock">
        <!-- Toggle Visibility for main layers -->
        <button title="Toggle Layer Visibility" id="toggleLayerButton">
            <span class="material-icons-round" id="visibilityIcon">visibility</span>
        </button>
        
        <!-- New Button to Toggle the Polygon Layer -->
        <button title="Toggle Polygon Layer" id="togglePolygonButton">
            <span class="material-icons-round" id="polygonVisibilityIcon">layers</span>
        </button>
        
        <!-- Slider wrapper for polygon opacity -->
        <div class="dock-slider">
            <input id="polygonOpacitySlider" type="range" min="0" max="0.5" step="0.01" value="0.1">
        </div>
        
        <!-- New Zoom Buttons replacing the text size buttons -->
        <button title="Zoom In" id="zoomInBtn">
            <span class="material-icons-round">zoom_in</span>
        </button>
        <button title="Zoom Out" id="zoomOutBtn">
            <span class="material-icons-round">zoom_out</span>
        </button>
        <button title="More Options" id="moreOptionsBtn">
            <span class="material-icons-round">menu</span>
        </button>
    </div>

    <!-- Popup Menu: For controls not requiring constant map visibility -->
    <div id="popupMenu">
        <div class="popup-content">
            <h3>Text Size</h3>
            <!-- Text Size Controls moved from the dock to the top of the popup -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <button title="Increase Text Size" id="textIncreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_plus_1</span>
                </button>
                <button title="Decrease Text Size" id="textDecreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_minus_1</span>
                </button>
            </div>
            <button class="close" id="closePopupBtn">
                <span class="material-icons-round">close</span>
            </button>
            <h3>Select Glide ratio</h3>
            <div id="policyConfigs"></div>
            <h3>Layers</h3>
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 15px;">
                <button id="peaksToggleBtn" class="config-button">
                    <span class="material-icons-round" id="peaksVisibilityIcon">terrain</span>
                    Peaks
                </button>
                <button id="passesToggleBtn" class="config-button">
                    <span class="material-icons-round" id="passesVisibilityIcon">route</span>
                    Passes
                </button>
            </div>
            <!-- IGC File Control with Icon -->
            <button id="igcFileButton">
                <span class="material-icons-round">folder_open</span>
                <span>Open IGC File</span>
            </button>
            <!-- New App Update section -->
            <h3>App Update</h3>
            <button id="appUpdateBtn" class="config-button">
                <span class="material-icons-round">system_update</span>
                Update App
            </button>
            <!-- Add this after the IGC File button in the popup menu -->
            <div style="margin-top: 15px; display: none;">
                <button id="cacheCurrentConfigBtn" class="config-button" style="display: flex; align-items: center; gap: 8px;">
                    <span class="material-icons-round">download</span>
                    <span>Cache Current Config for Offline Use</span>
                </button>
                <div id="cacheProgress" style="display: none; margin-top: 10px;">
                    <div style="margin-bottom: 5px;">Caching files: <span id="cacheCount">0</span>/<span id="totalFiles">0</span></div>
                    <div style="width: 100%; height: 4px; background: #eee; border-radius: 2px;">
                        <div id="progressBar" style="width: 0%; height: 100%; background: #4CAF50; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>

            <!-- Add new section for caching background map -->
            <div style="margin-top: 15px; display: none;">
                <button id="cacheBackgroundMapBtn" class="config-button" style="display: flex; align-items: center; gap: 8px;">
                    <span class="material-icons-round">map</span>
                    <span>Cache Background Map for Offline Use</span>
                </button>
                <div id="mapCacheProgress" style="display: none; margin-top: 10px;">
                    <div style="margin-bottom: 5px;">Caching tiles: <span id="mapCacheCount">0</span>/<span id="mapTotalTiles">0</span></div>
                    <div style="width: 100%; height: 4px; background: #eee; border-radius: 2px;">
                        <div id="mapProgressBar" style="width: 0%; height: 100%; background: #4CAF50; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>

            <h3>Warning</h3>
            <p>This is a new experimental tool. Problems will arise that have not been encountered before in the gliding community.</p>
            <p>I am not sure that 100m above ground is big enough a margin to be safe above the passes.</p>
            <p>Airspace is not taken into account. Downdrafts are not taken into account. Wind is not taken into account.</p>
            <p>The airfield list might not be accurate, some airfields might be unservicable or closed.</p>
            <p>Check on a real map that the indications make sense.</p>
            <p>Speak with the owner of the glider (your club's instructors for example) about using this tool. They might foresee problems that you and the author have not anticipated and save your life.</p>
            <p>The author is not liable for any damage or injury that might occur by using this tool.</p>
            <!-- Hidden file input triggered by the IGC file button -->
            <input type="file" id="igcFileInput" accept="*/*" style="display: none;">
        </div>
    </div>

    <!-- Add this right after the opening <body> tag -->
    <div id="installPrompt" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 8px; z-index: 1000; text-align: center;">
        <p style="margin: 0 0 10px 0;">Install MountainCircles Map for offline use?</p>
        <button id="installButton" style="background: #4CAF50; border: none; color: white; padding: 8px 16px; border-radius: 4px; margin-right: 10px;">Install</button>
        <button id="cancelInstall" style="background: #666; border: none; color: white; padding: 8px 16px; border-radius: 4px;">Not Now</button>
    </div>

    <script>
        const BASE_PATH = '/MountainCircles-map-beta';

        // Register service worker immediately (moved to top for early activation)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register(`${BASE_PATH}/sw.js`, { scope: `${BASE_PATH}/` })
                    .then(registration => {
                        console.log('Service Worker registered:', registration.scope);
                        registration.update();
                    })
                    .catch(error => console.error('Service Worker registration failed:', error));
            });

            // Remove the previous sourcedata-based spinner handler.
            // Instead, use these spinner control variables and message listener:
            let activeFetches = 0;
            let spinnerTimeout = null;

            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data.type === 'fetchStart') {
                    activeFetches++;
                    // Debounce showing the spinner for 200ms
                    if (!spinnerTimeout) {
                        spinnerTimeout = setTimeout(() => {
                            document.getElementById('spinner').style.display = 'block';
                        }, 200);
                    }
                } else if (event.data.type === 'fetchComplete') {
                    activeFetches = Math.max(0, activeFetches - 1);
                    if (activeFetches === 0) {
                        clearTimeout(spinnerTimeout);
                        spinnerTimeout = null;
                        document.getElementById('spinner').style.display = 'none';
                    }
                } else if (event.data.type === 'loadWarning' || event.data.type === 'loadError') {
                    alert(event.data.message);
                } else if (event.data.type === 'cacheStart') {
                    // Optional: handle caching start message if desired.
                } else if (event.data.type === 'cacheProgress') {
                    const { completed, total } = event.data;
                    document.getElementById('cacheCount').textContent = completed;
                    document.getElementById('totalFiles').textContent = total;
                    const percentage = (completed / total) * 100;
                    document.getElementById('progressBar').style.width = `${percentage}%`;
                } else if (event.data.type === 'cacheComplete') {
                    updateConfigButtonStyles();
                    document.getElementById('cacheProgress').style.display = 'none';
                    document.getElementById('progressBar').style.width = '0%';
                } else if (event.data.type === 'cacheTileComplete') {
                    // Handled in cacheTiles
                } else if (event.data.type === 'cacheError') {
                    console.error(event.data.message);
                }
            });
        }

        const customStyle = {
            "version": 8,
            "name": "Custom Map",
            "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
            "sources": {
                "custom-tiles": {
                    "type": "raster",
                    "tiles": [
                        "./tiles/{z}/{x}/{y}.png"  // Relative path to your tiles folder on GitHub Pages
                    ],
                    "tileSize": 256,
                    "maxzoom": 12,  // This ensures that even if you zoom past level 12, the map uses these tiles.
                    "attribution": "Map data Â© OpenStreetMap contributors + Alos topographic data"
                }
            },
            "layers": [
                {
                    "id": "custom-tiles",
                    "type": "raster",
                    "source": "custom-tiles",
                    "minzoom": 0   // Remove maxzoom here so the layer remains visible at higher zooms
                }
            ]
        };
        const policies = {
            'alps': [
                '10-100-250-4200',
                '20-100-250-4200',
                '25-100-250-4200',
                '30-100-250-4200',
            ],
            'West_alps_with_fields': [
                '10-100-250-4200',
                '20-100-250-4200',
                '25-100-250-4200',
                '30-100-250-4200',
            ]
        };

        // Update the currentConfig to include policy
        let currentPolicy = 'alps';  // Default policy
        let currentConfig = currentPolicy + '/' + '20-100-250-4200';  // Default config with policy prefix

        // Create policy sections and their config buttons
        const policyConfigsContainer = document.getElementById('policyConfigs');
        
        Object.entries(policies).forEach(([policy, configs]) => {
            const policySection = document.createElement('div');
            policySection.className = 'policy-section';
            
            const policyHeader = document.createElement('h3');
            policyHeader.textContent = policy;
            policySection.appendChild(policyHeader);
            
            const configButtonsContainer = document.createElement('div');
            configButtonsContainer.className = 'config-buttons';
            configButtonsContainer.style.display = 'flex';
            configButtonsContainer.style.flexWrap = 'wrap';
            configButtonsContainer.style.justifyContent = 'center';
            configButtonsContainer.style.gap = '5px';
            configButtonsContainer.style.marginBottom = '15px';
            
            configs.forEach(cfg => {
                const btn = document.createElement('button');
                btn.textContent = cfg.split('-')[0];  // Use first part as button label
                btn.className = 'config-button';
                const fullConfig = policy + '/' + cfg;  // Store the full config path
                
                btn.setAttribute('data-config', fullConfig);
                
                btn.onclick = () => {
                    switchConfig(fullConfig);
                    document.getElementById('popupMenu').style.display = "none";
                    console.log("Switched to configuration: " + fullConfig);
                };
                configButtonsContainer.appendChild(btn);
            });
            
            policySection.appendChild(configButtonsContainer);
            policyConfigsContainer.appendChild(policySection);
        });

        // Initialize visibility state
        let peaksVisible = true;
        let passesVisible = true;

        // Function to update layer visibility and icon
        function updateLayerVisibility(layerId, visible, iconId) {
            if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', visible ? 'visible' : 'none');
                document.getElementById(iconId).style.opacity = visible ? '1' : '0.5';
            }
        }

        // Peaks toggle button
        document.getElementById('peaksToggleBtn').addEventListener('click', () => {
            peaksVisible = !peaksVisible;
            updateLayerVisibility('peaks-symbols', peaksVisible, 'peaksVisibilityIcon');
        });

        // Passes toggle button
        document.getElementById('passesToggleBtn').addEventListener('click', () => {
            passesVisible = !passesVisible;
            updateLayerVisibility('passes-symbols', passesVisible, 'passesVisibilityIcon');
        });

        // Update the switchConfig function to maintain visibility state
        function switchConfig(cfg) {
            removeDynamicLayers();
            removeGeoJSONLayers();
            updateParametersBox(cfg.split('/')[1]);
            currentConfig = cfg;
            currentPolicy = cfg.split('/')[0];
            addGeoJSONLayers();
            
            updateLayerVisibility('peaks-symbols', peaksVisible, 'peaksVisibilityIcon');
            updateLayerVisibility('passes-symbols', passesVisible, 'passesVisibilityIcon');
            
            if (map.getLayer('passes-symbols')) {
                map.moveLayer('passes-symbols');
            }
            if (map.getLayer('peaks-symbols')) {
                map.moveLayer('peaks-symbols');
            }
            if (map.getLayer('location-marker-circle')) {
                map.moveLayer('location-marker-circle');
            }

            if (isRunningStandalone() && isMobileDevice()) {
                updateCacheButtonStyles();
            }
        }

        // Update addGeoJSONLayers to use the policy name in file paths
        function addGeoJSONLayers() {
            const configParts = currentConfig.split('/');
            const configPrefix = configParts[1].split('-').slice(0, 3).join('-');
            const policyName = configParts[0];

            if (!map.getSource('geojson-data')) {
                map.addSource('geojson-data', {
                    type: 'geojson',
                    data: currentConfig + '/aa_' + policyName + '_' + configPrefix + '.geojson'
                });
            } else {
                map.getSource('geojson-data').setData(currentConfig + '/aa_' + policyName + '_' + configPrefix + '.geojson');
            }
            
            if (!map.getSource('polygons')) {
                map.addSource('polygons', {
                    type: 'geojson',
                    data: currentConfig + '/aa_' + policyName + '_' + configPrefix + '_sectors1.geojson'
                });
            } else {
                map.getSource('polygons').setData(currentConfig + '/aa_' + policyName + '_' + configPrefix + '_sectors1.geojson');
            }
            
            if (!map.getLayer('polygons-layer')) {
                map.addLayer({
                    id: 'polygons-layer',
                    type: 'fill',
                    source: 'polygons',
                    paint: {
                        'fill-color': [
                            "match",
                            ["get", "color_id"],
                            0, "#0000FF",
                            1, "#FF00FF",
                            2, "#FFFF00",
                            3, "#00FFFF",
                            4, "#00FF00",
                            5, "#FF0000",
                            6, "#FFA500",
                            "#000000"
                        ],
                        'fill-opacity': 0.1
                    }
                });
            }
            
            if (!map.getLayer('linestrings-layer')) {
                map.addLayer({
                    id: 'linestrings-layer',
                    type: 'line',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });
            }
            
            if (!map.getLayer('points-layer')) {
                map.addLayer({
                    id: 'points-layer',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#ff0000',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#fff'
                    }
                });
            }
            
            if (!map.getLayer('points-layer-clickable')) {
                map.addLayer({
                    id: 'points-layer-clickable',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 20,
                        'circle-color': '#000000',
                        'circle-opacity': 0
                    }
                });
            }
            
            if (!map.getLayer('linestrings-labels')) {
                map.addLayer({
                    id: 'linestrings-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
            
            if (!map.getLayer('points-labels')) {
                map.addLayer({
                    id: 'points-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 7,
                    filter: ['==', '$type', 'Point'],
                    layout: {
                        'text-field': '{name}',
                        'text-size': baseTextSize + 5,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0.8, 0.8],
                        'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
                        'text-radial-offset': 0.8,
                        'symbol-spacing': 20
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
        }
        
        let map;
        
        function updateParametersBox(cfg) {
            console.log("updateParametersBox called with:", cfg);
            const configOnly = cfg.split('/')[1] || cfg;
            const parts = configOnly.split('-');
            console.log("parts after split:", parts);
            if (parts.length >= 3) {
                const labelText = "L/D " + parts[0] + "-ground " + parts[1] + "m-circuit " + parts[2] + "m";
                console.log("setting label to:", labelText);
                document.getElementById('parametersBox').textContent = labelText;
            }
        }
        
        updateParametersBox(currentConfig);
        
        function removeGeoJSONLayers() {
            const layersToRemove = [
                'linestrings-layer',
                'linestrings-labels',
                'points-layer',
                'points-labels',
                'points-layer-clickable',
                'polygons-layer'
            ];
            layersToRemove.forEach(id => {
                if (map.getLayer(id)) {
                    map.removeLayer(id);
                }
            });
            const sourcesToRemove = ['geojson-data', 'polygons'];
            sourcesToRemove.forEach(id => {
                if (map.getSource(id)) {
                    map.removeSource(id);
                }
            });
        }
        
        function removeDynamicLayers() {
            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if(layer.id.startsWith('dynamic-lines-')) {
                    if(map.getLayer(layer.id)) { 
                        map.removeLayer(layer.id);
                    }
                }
            });
            
            const sourceIds = Object.keys(map.style.sourceCaches);
            sourceIds.forEach(sourceId => {
                if(sourceId.startsWith('dynamic-lines-')) {
                    if(map.getSource(sourceId)) { 
                        map.removeSource(sourceId);
                    }
                }
            });
        }
        
        let baseTextSize = 14;

        function updateAllLabelSizes() {
            map.getStyle().layers.forEach(layer => {
                if (layer.type === 'symbol' && layer.layout && layer.layout["text-size"] !== undefined) {
                    if (layer.id === 'points-labels') {
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize + 5);
                    } else {
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize);
                    }
                }
            });
        }

        function handlePointClick(e) {
            console.log("Point clicked event:", e);
            if (!e.features || !e.features.length) return;
        
            const feature = e.features[0];
            if (!feature.properties || !feature.properties.filename) {
                console.warn("Clicked feature missing 'filename' property:", feature);
                return;
            }

            const filePath = currentConfig + "/" + feature.properties.filename;
            const dynamicLayerId = 'dynamic-lines-' + currentConfig + '-' + feature.properties.filename;
            const dynamicSourceId = dynamicLayerId + '-source';
            const dynamicLabelId = dynamicLayerId + '-labels';

            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if (layer.id.startsWith('dynamic-lines-') && layer.id !== dynamicLayerId) {
                    if (map.getLayer(layer.id)) {
                        map.setLayoutProperty(layer.id, 'visibility', 'none');
                    }
                    const otherLabelId = layer.id + '-labels';
                    if (map.getLayer(otherLabelId)) {
                        map.setLayoutProperty(otherLabelId, 'visibility', 'none');
                    }
                }
            });

            if (map.getLayer(dynamicLayerId)) {
                let currentVisibility = map.getLayoutProperty(dynamicLayerId, 'visibility') || 'visible';
                if (currentVisibility === 'visible') {
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'none');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'visible');
                    }
                } else {
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'visible');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                    }
                }
            } else {
                if (map.getLayer('linestrings-layer')) {
                    map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                }
                if (map.getLayer('linestrings-labels')) {
                    map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                }
                console.log("Adding dynamic layer for:", filePath);
                map.addSource(dynamicSourceId, {
                    type: 'geojson',
                    data: filePath
                });

                map.addLayer({
                    id: dynamicLayerId,
                    type: 'line',
                    source: dynamicSourceId,
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });

                map.addLayer({
                    id: dynamicLabelId,
                    type: 'symbol',
                    source: dynamicSourceId,
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }

            if (map.getLayer('passes-symbols')) {
                map.moveLayer('passes-symbols');
            }
            if (map.getLayer('peaks-symbols')) {
                map.moveLayer('peaks-symbols');
            }
            if (map.getLayer('location-marker-circle')) {
                map.moveLayer('location-marker-circle');
            }

            const mainVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
            document.getElementById('visibilityIcon').textContent = mainVisibility === 'visible' ? 'visibility' : 'visibility_off';
        }
        
        const currentStyle = customStyle;
        
        map = new maplibregl.Map({
            container: 'map',
            style: currentStyle,
            bounds: [[4.9698169, 43.6088902], [13.696105, 47.5644488]],
            maxBounds: [[4.57526, 43.45699], [13.96581, 47.98810]],
            maxZoom: 16,
            fitBoundsOptions: {
                padding: 50,
                maxZoom: 12,
                duration: 1000
            },
            attributionControl: false,
            renderWorldCopies: false
        });
        
        map.on('load', () => {
            console.log('Map load event triggered');
            
            map.addSource('peaks', {
                type: 'geojson',
                data: 'peaks.geojson'
            });
            map.addSource('passes', {
                type: 'geojson',
                data: 'passes.geojson'
            });
            console.log('Added peaks and passes sources');

            const size = 15;
            const peakImage = new Image(size, size);
            const passImage = new Image(size, size);
            const peakCanvas = document.createElement('canvas');
            const passCanvas = document.createElement('canvas');
            peakCanvas.width = size;
            peakCanvas.height = size;
            passCanvas.width = size;
            passCanvas.height = size;
            const peakContext = peakCanvas.getContext('2d');
            const passContext = passCanvas.getContext('2d');
            
            peakContext.beginPath();
            peakContext.moveTo(size/2, 0);
            peakContext.lineTo(size, size);
            peakContext.lineTo(0, size);
            peakContext.closePath();
            peakContext.fillStyle = '#FF8C00';
            peakContext.fill();
            
            passContext.beginPath();
            passContext.moveTo(0, 0);
            passContext.lineTo(size, 0);
            passContext.lineTo(size/2, size);
            passContext.closePath();
            passContext.fillStyle = '#006400';
            passContext.fill();
            
            peakImage.src = peakCanvas.toDataURL();
            passImage.src = passCanvas.toDataURL();
            
            Promise.all([
                new Promise(resolve => peakImage.onload = resolve),
                new Promise(resolve => passImage.onload = resolve)
            ]).then(() => {
                console.log('Triangle images loaded');
                map.addImage('peak-triangle', peakImage);
                map.addImage('pass-triangle', passImage);
                console.log('Added triangle images to map');

                map.addLayer({
                    id: 'peaks-symbols',
                    type: 'symbol',
                    source: 'peaks',
                    minzoom: 10,
                    layout: {
                        'icon-image': 'peak-triangle',
                        'icon-size': 1,
                        'icon-anchor': 'bottom',
                        'text-field': ['get', 'namele'],
                        'text-size': baseTextSize,
                        'text-anchor': 'top',
                        'text-offset': [0, 0.5],
                        'icon-allow-overlap': false,
                        'icon-ignore-placement': false,
                        'icon-optional': true,
                        'icon-padding': 2,
                        'symbol-spacing': 250,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-optional': true,
                        'text-padding': 2,
                        'text-field': [
                            'step',
                            ['zoom'],
                            '',
                            11, ['get', 'namele']
                        ]
                    },
                    paint: {
                        'text-color': '#654321', 
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });

                map.addLayer({
                    id: 'passes-symbols',
                    type: 'symbol',
                    source: 'passes',
                    minzoom: 10,
                    layout: {
                        'icon-image': 'pass-triangle',
                        'icon-size': 1,
                        'icon-anchor': 'top',
                        'text-field': ['get', 'name'],
                        'text-size': baseTextSize,
                        'text-anchor': 'bottom',
                        'text-offset': [0, -0.5],
                        'icon-allow-overlap': false,
                        'icon-ignore-placement': false,
                        'icon-optional': true,
                        'icon-padding': 2,
                        'symbol-spacing': 250,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-optional': true,
                        'text-padding': 2,
                        'text-field': [
                            'step',
                            ['zoom'],
                            '',
                            11, ['get', 'name']
                        ]
                    },
                    paint: {
                        'text-color': '#006400',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
                console.log('Added peaks and passes symbol layers');
            });

            addGeoJSONLayers();
            
            map.addSource('location-marker', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [0, 0]
                    }
                }
            });

            map.addLayer({
                id: 'location-marker-circle',
                type: 'circle',
                source: 'location-marker',
                paint: {
                    'circle-radius': 8,
                    'circle-color': '#0066FF',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#FFFFFF'
                }
            });

            if ('geolocation' in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 5000
                };
                
                navigator.geolocation.watchPosition(
                    updateLocation,
                    (error) => {
                        console.error('Error getting location:', error);
                    },
                    options
                );
            } else {
                console.warn('Geolocation is not supported by this browser.');
            }

            if (map.getLayer('points-layer-clickable')) {
                map.on('click', 'points-layer-clickable', handlePointClick);
            }

            const cacheButton = document.getElementById('cacheCurrentConfigBtn');
            const mapCacheButton = document.getElementById('cacheBackgroundMapBtn');
            const cacheContainer = cacheButton.parentElement;
            const mapCacheContainer = mapCacheButton.parentElement;

            [cacheContainer, mapCacheContainer].forEach(container => {
                container.style.display = 'none';
                container.style.justifyContent = 'center';
                container.style.alignItems = 'center';
                container.style.gap = '5px';
                container.style.marginBottom = '15px';
                container.style.width = '100%';
            });

            if (isRunningStandalone() && isMobileDevice()) {
                cacheContainer.style.display = 'flex';
                mapCacheContainer.style.display = 'flex';
                document.getElementById('zoomInBtn').style.display = 'none';
                document.getElementById('zoomOutBtn').style.display = 'none';
            } 
        });
        
        function isRunningStandalone() {
            return window.matchMedia('(display-mode: standalone)').matches ||
                   window.navigator.standalone ||
                   document.referrer.includes('android-app://');
        }

        const polygonOpacitySlider = document.getElementById('polygonOpacitySlider');
        polygonOpacitySlider.addEventListener('input', function() {
            const opacity = parseFloat(this.value);
            if (map.getLayer('polygons-layer')) {
                map.setPaintProperty('polygons-layer', 'fill-opacity', opacity);
            }
        });

        const popupMenu = document.getElementById('popupMenu');
        document.getElementById('moreOptionsBtn').addEventListener('click', () => {
            popupMenu.style.display = "flex";
            updateConfigButtonStyles();
        });
        document.getElementById('closePopupBtn').addEventListener('click', () => {
            popupMenu.style.display = "none";
        });

        popupMenu.addEventListener('click', (e) => {
            if(e.target === popupMenu) {
                popupMenu.style.display = "none";
            }
        });

        function igcToGeoJSON(igcContent) {
            const lines = igcContent.split('\n');
            const coordinates = [];
            let metadata = {};

            for (const line of lines) {
                if (line.startsWith('B')) {
                    try {
                        const time = line.substring(1, 7);
                        const latRaw = line.substring(7, 15);
                        const latDeg = parseInt(latRaw.substring(0, 2));
                        const latMin = parseFloat(latRaw.substring(2, 7)) / 1000;
                        const latDir = latRaw.substring(7, 8);
                        const lonRaw = line.substring(15, 24);
                        const lonDeg = parseInt(lonRaw.substring(0, 3));
                        const lonMin = parseFloat(lonRaw.substring(3, 8)) / 1000;
                        const lonDir = lonRaw.substring(8, 9);
                        const altPressure = parseInt(line.substring(25, 30));
                        const altGNSS = parseInt(line.substring(30, 35));

                        let latitude = latDeg + (latMin / 60);
                        if (latDir === 'S') latitude = -latitude;

                        let longitude = lonDeg + (lonMin / 60);
                        if (lonDir === 'W') longitude = -longitude;

                        const altitude = altPressure > 0 ? altPressure : altGNSS;

                        coordinates.push([longitude, latitude, altitude]);
                    } catch (error) {
                        console.warn('Error parsing B record:', line, error);
                    }
                }
                else if (line.startsWith('H')) {
                    try {
                        const headerType = line.substring(1, 5);
                        const headerValue = line.substring(5).trim();

                        if (headerType.startsWith('FDT')) metadata.date = headerValue;
                        if (headerType.startsWith('FPL')) metadata.pilot = headerValue;
                        if (headerType.startsWith('FGT')) metadata.gliderType = headerValue;
                        if (headerType.startsWith('FGI')) metadata.gliderID = headerValue;
                    } catch (error) {
                        console.warn('Error parsing H record:', line, error);
                    }
                }
            }

            const geojson = {
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    },
                    properties: {
                        ...metadata,
                        sourceFormat: 'IGC',
                        coordinateProperties: {
                            altitudes: coordinates.map(coord => coord[2])
                        }
                    }
                }]
            };

            return geojson;
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            document.getElementById('popupMenu').style.display = "none";
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const igcContent = e.target.result;
                const geojsonData = igcToGeoJSON(igcContent);
                console.log('Converted IGC to GeoJSON:', geojsonData);
                
                const baseLayerId = 'igc-layer-' + file.name.replace(/\W/g, '');
                let layerId = baseLayerId;
                if (map.getLayer(layerId)) {
                    layerId = baseLayerId + '-' + Date.now();
                }
                const sourceId = layerId + '-source';
                
                map.addSource(sourceId, {
                    type: 'geojson',
                    data: geojsonData
                });
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#0000FF',
                        'line-width': 2
                    }
                });
                
                const coords = geojsonData.features[0].geometry.coordinates;
                let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
                coords.forEach(coord => {
                    const [lng, lat] = coord;
                    if (lng < minLng) minLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lng > maxLng) maxLng = lng;
                    if (lat > maxLat) maxLat = lat;
                });
                const bounds = [[minLng, minLat], [maxLng, maxLat]];
                
                map.fitBounds(bounds, {
                    padding: 50,
                    maxZoom: 14,
                    duration: 1000
                });
                
                const altPoints = {
                    type: 'FeatureCollection',
                    features: coords.map(coord => ({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [coord[0], coord[1]]
                        },
                        properties: {
                            altitude: coord[2]
                        }
                    }))
                };

                const altSourceId = layerId + '-altitudes-source';
                map.addSource(altSourceId, {
                    type: 'geojson',
                    data: altPoints
                });

                map.addLayer({
                    id: layerId + '-altitudes',
                    type: 'symbol',
                    source: altSourceId,
                    minzoom: 9,
                    layout: {
                        'text-field': '{altitude}',
                        'text-size': baseTextSize,
                        'text-offset': [0, -0.5]
                    },
                    paint: {
                        'text-color': '#0000FF',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });

                if (map.getLayer('location-marker-circle')) {
                    map.moveLayer('location-marker-circle');
                }
            };
            reader.readAsText(file);
        }

        document.getElementById('igcFileButton').addEventListener('click', function() {
            document.getElementById('igcFileInput').click();
            this.blur();
        });
        document.getElementById('igcFileInput').addEventListener('change', handleFileSelect);

        document.getElementById('toggleLayerButton').addEventListener('click', () => {
            const layerIds = ['linestrings-layer', 'linestrings-labels'];
            let newVisibility = 'visible';
            if (map.getLayer('linestrings-layer')) {
                const currentVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
                newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            }
            layerIds.forEach(id => {
                if (map.getLayer(id)) {
                    map.setLayoutProperty(id, 'visibility', newVisibility);
                }
            });
            document.getElementById('visibilityIcon').textContent = newVisibility === 'visible' ? 'visibility' : 'visibility_off';
        });

        document.getElementById('zoomInBtn').addEventListener('click', () => {
            map.zoomIn();
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            map.zoomOut();
        });

        document.getElementById('textDecreaseBtn').addEventListener('click', () => {
            baseTextSize = Math.max(1, baseTextSize - 1);
            updateAllLabelSizes();
        });

        document.getElementById('textIncreaseBtn').addEventListener('click', () => {
            baseTextSize += 1;
            updateAllLabelSizes();
        });

        document.getElementById('togglePolygonButton').addEventListener('click', () => {
            const polygonLayerId = 'polygons-layer';
            let currentVisibility = map.getLayoutProperty(polygonLayerId, 'visibility') || 'visible';
            let newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            map.setLayoutProperty(polygonLayerId, 'visibility', newVisibility);
            document.getElementById('polygonVisibilityIcon').textContent = newVisibility === 'visible' ? 'layers' : 'layers_clear';
        });

        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            if (isMobileDevice()) {
                deferredPrompt = e;
                document.getElementById('installPrompt').style.display = 'block';
            } else {
                document.getElementById('installPrompt').style.display = 'none';
            }
        });

        document.getElementById('installButton').addEventListener('click', async () => {
            if (deferredPrompt) {
                await deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                deferredPrompt = null;
                document.getElementById('installPrompt').style.display = 'none';
            }
        });

        document.getElementById('cancelInstall').addEventListener('click', () => {
            document.getElementById('installPrompt').style.display = 'none';
        });

        function updateLocation(position) {
            if (!map.getSource('location-marker')) {
                console.warn('Location marker source not found');
                return;
            }
            
            const coords = [position.coords.longitude, position.coords.latitude];
            
            map.getSource('location-marker').setData({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: coords
                }
            });
        }

        async function cacheConfigurationFiles() {
            const configParts = currentConfig.split('/');
            const policy = configParts[0];
            const config = configParts[1];
            const configPrefix = config.split('-').slice(0, 3).join('-');
            
            document.getElementById('cacheProgress').style.display = 'block';
            const progressBar = document.getElementById('progressBar');
            const cacheCount = document.getElementById('cacheCount');
            const totalFiles = document.getElementById('totalFiles');
            
            try {
                const mainGeojsonUrl = `./${currentConfig}/aa_${policy}_${configPrefix}.geojson`;
                const sectorsGeojsonUrl = `./${currentConfig}/aa_${policy}_${configPrefix}_sectors1.geojson`;
                
                const response = await fetch(mainGeojsonUrl);
                const data = await response.json();
                
                const pointFeatures = data.features.filter(f => 
                    f.geometry.type === 'Point' && f.properties.filename);
                
                const files = [
                    `${currentConfig}/aa_${policy}_${configPrefix}.geojson`,
                    `${currentConfig}/aa_${policy}_${configPrefix}_sectors1.geojson`,
                    ...pointFeatures.map(f => `${currentConfig}/${f.properties.filename}`)
                ];
                
                const total = files.length;
                totalFiles.textContent = total;
                
                const registration = await navigator.serviceWorker.ready;
                registration.active.postMessage({
                    type: 'cacheFiles',
                    files: files,
                    config: currentConfig
                });
                
            } catch (error) {
                console.error('Error caching configuration:', error);
                document.getElementById('cacheProgress').style.display = 'none';
            }
        }

        document.getElementById('cacheCurrentConfigBtn').addEventListener('click', cacheConfigurationFiles);

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        async function isConfigCached(config) {
            const configParts = config.split('/');
            const policy = configParts[0];
            const configPrefix = configParts[1].split('-').slice(0, 3).join('-');
            const mainGeojsonUrl = `${BASE_PATH}/${config}/aa_${policy}_${configPrefix}.geojson`;
            
            try {
                const cache = await caches.open('mountaincircles-dynamic-v1');
                const response = await cache.match(mainGeojsonUrl);
                return !!response;
            } catch (error) {
                return false;
            }
        }

        async function updateConfigButtonStyles() {
            const buttons = document.querySelectorAll('.config-buttons .config-button');
            
            for (const button of buttons) {
                const buttonConfig = button.getAttribute('data-config');
                if (buttonConfig) {
                    const isCached = await isConfigCached(buttonConfig);
                    button.style.border = isCached ? '2px solid #4CAF50' : 'none';
                }
            }
        }

        async function cacheTiles() {
            document.getElementById('mapCacheProgress').style.display = 'block';
            const progressBar = document.getElementById('mapProgressBar');
            const cacheCount = document.getElementById('mapCacheCount');
            const totalTiles = document.getElementById('mapTotalTiles');

            const bounds = [[4.9698169, 43.6088902], [13.696105, 47.5644488]];
            const minZoom = 1;
            const maxZoom = 12;

            const tiles = [];
            for (let z = minZoom; z <= maxZoom; z++) {
                const northwest = latLngToTile(bounds[0][1], bounds[0][0], z);
                const southeast = latLngToTile(bounds[1][1], bounds[1][0], z);

                const minX = Math.min(northwest.x, southeast.x);
                const maxX = Math.max(northwest.x, southeast.x);
                const minY = Math.min(northwest.y, southeast.y);
                const maxY = Math.max(northwest.y, southeast.y);

                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        tiles.push({ x, y, z });
                    }
                }
            }

            totalTiles.textContent = tiles.length;

            let completedTiles = 0;
            const messageHandler = (event) => {
                if (event.data.type === 'cacheTileComplete') {
                    completedTiles++;
                    cacheCount.textContent = completedTiles;
                    const percentage = (completedTiles / tiles.length) * 100;
                    progressBar.style.width = `${percentage}%`;

                    if (completedTiles === tiles.length) {
                        navigator.serviceWorker.removeEventListener('message', messageHandler);
                        document.getElementById('mapCacheProgress').style.display = 'none';
                        progressBar.style.width = '0%';
                    }
                }
            };

            navigator.serviceWorker.addEventListener('message', messageHandler);

            const registration = await navigator.serviceWorker.ready;
            registration.active.postMessage({
                type: 'cacheTiles',
                tiles: tiles,
                basePath: './tiles'
            });
        }

        function latLngToTile(lat, lng, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y };
        }

        document.getElementById('cacheBackgroundMapBtn').addEventListener('click', cacheTiles);

        function isIOS() {
          return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        if (isIOS()) {
          const installPrompt = document.getElementById('installPrompt');
          installPrompt.innerHTML = `
            <p>To install this app, tap the share button in Safari and then select "Add to Home Screen".</p>
            <button id="closeInstallPrompt" style="background: #666; color: #fff; padding: 8px 16px; border: none; border-radius: 4px;">Close</button>
          `;
          installPrompt.style.display = 'block';

          document.getElementById('closeInstallPrompt').addEventListener('click', function() {
            installPrompt.style.display = 'none';
          });
        }

        function updateApp() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistration().then(registration => {
                    if (registration) {
                        registration.update().then(() => {
                            Promise.all([
                                fetch(`${BASE_PATH}/index.html`, { cache: 'reload' }),
                                fetch(`${BASE_PATH}/sw.js`, { cache: 'reload' })
                            ])
                            .then(() => {
                                alert('App update completed. Please reload the page to see the newest version.');
                            })
                            .catch(error => {
                                console.error('Error updating app:', error);
                                alert('App update failed.');
                            });
                        });
                    }
                });
            }
        }

        document.getElementById('appUpdateBtn').addEventListener('click', updateApp);

    </script>
</body>
</html>