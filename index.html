<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="/MountainCircles---map/">
    <title>MountainCircles Map - Beta</title>
    <!-- Using jsDelivr instead of unpkg to avoid potential network errors on Windows -->
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; }
        #map { width: 100%; height: 100vh; }
        /* Simple style for the basemap switcher */
        #styleSwitcher {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        /* Container uses flex, aligning items in the center vertically */
        #polygonOpacityControl {
            position: absolute;
            top: 50px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
        }
        /* Make the button a flex container so its content centers */
        #polygonOpacityControl button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin-right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            min-height: 24px; /* ensures the button is at least 24px tall */
        }
        /* Force the Material Icons font with !important */
        .material-icons-round {
            font-family: 'Material Icons Round' !important;
            font-size: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            color: #000;
        }
        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- MAP DOCK (apple-dock style) --------------- */
        #mapDock {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            flex-direction: column;
            max-height: 100%;
            flex-wrap: wrap-reverse;
            gap: 10px;
            z-index: 1100;
        }

        /* -------------------------- */
        /* Slider Container (Dock Box) */
        /* -------------------------- */
        .dock-slider {
            width: 48px;       /* Same as other button width */
            height: 150px;     /* Give enough room for the rotated slider */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.8); /* Light mode: white-ish background */
            border-radius: 8px;
            padding: 8px;
            box-sizing: border-box;
        }

        /* Slider styling remains the same in landscape mode */
        #polygonOpacitySlider {
            width: 150px;  /* Length of the slider track */
            -webkit-transform: rotate(-90deg);
            -ms-transform: rotate(-90deg);
            transform: rotate(-90deg);
            -webkit-appearance: none; /* Remove default styling */
            background: transparent;  /* Needed for custom pseudo-elements */
        }

        /* Portrait mode: dock is horizontal, so the slider must be horizontal */
        @media (orientation: portrait) {
            #mapDock {
                position: fixed;
                top: 10px;
                left: 0;
                right: 0;
                width: 100%;
                padding: 0 0; /* Optional: Add some horizontal spacing */
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center; /* Center items in each row */
                gap: 10px;
                transform: translateY(0);
            }
            .dock-slider {
                /* Adjust container to have the same height as other buttons */
                width: 150px;
                height: 48px;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 8px;
                padding: 8px;
                box-sizing: border-box;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            /* Force the slider to be horizontal by resetting its rotation */
            .dock-slider #polygonOpacitySlider {
                -webkit-transform: rotate(0deg) !important;
                -ms-transform: rotate(0deg) !important;
                transform: rotate(0deg) !important;
                width: 100% !important;
            }
            /* Hide zoom buttons that aren't needed in portrait */
            #zoomInBtn,
            #zoomOutBtn {
                display: none;
            }
        }

        /* Dark mode adjustments: use a grey background similar to the buttons */
        @media (prefers-color-scheme: dark) {
            .dock-slider {
                background: rgba(20, 20, 20, 0.8);
            }
        }

        /* ===================== */
        /* Custom Slider Styling */
        /* ===================== */

        /* For Webkit Browsers (Chrome, Safari, Opera) */
        #polygonOpacitySlider::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            margin-top: -7px; /* Center the thumb on the track */
            cursor: pointer;
        }

        /* For Firefox */
        #polygonOpacitySlider::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* For IE */
        #polygonOpacitySlider::-ms-track {
            width: 100%;
            height: 6px;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }
        #polygonOpacitySlider::-ms-fill-lower {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-fill-upper {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* Dark mode adjustments: use a darker grey for the slider track */
        @media (prefers-color-scheme: dark) {
            #polygonOpacitySlider::-webkit-slider-runnable-track {
                background: #555;
            }
            #polygonOpacitySlider::-moz-range-track {
                background: #555;
            }
            #polygonOpacitySlider::-ms-fill-lower,
            #polygonOpacitySlider::-ms-fill-upper {
                background: #555;
            }
        }

        @media (pointer: coarse) {
            #zoomInBtn,
            #zoomOutBtn {
                display: none;
            }
        }

        /* Map Dock Buttons: Remove transition and hover effects */
        #mapDock button {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            outline: none;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: none;  /* Disabled transition for scaling and background changes */
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #mapDock button:hover {
            transform: none;   /* Disable zooming (scaling) */
            background: rgba(255, 255, 255, 0.8);  /* Keep same background */
        }

        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            #mapDock button {
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock button:hover {
                transform: none;   /* Disable zooming in dark mode as well */
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- POPUP MENU (centered on screen) --------------- */
        #popupMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 1200;
        }
        #popupMenu .popup-content {
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            max-height: 90vh; /* Limit the height to 90% of the viewport height */
            overflow-y: auto; /* Add vertical scrolling if content overflows */
            position: relative;
            font-family: sans-serif;
            text-align: center;
            color: #000;
        }
        
        /* Config buttons container: centers buttons and adds gap with extra bottom margin */
        #popupMenu #configButtons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;  /* 5px gap between config buttons */
            margin-bottom: 15px;
        }

        /* Style for configuration buttons inside the popup menu */
        #popupMenu #configButtons button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;  /* fallback margin, in addition to the flex gap */
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        #popupMenu #configButtons button:hover {
            background: #ddd;
        }

        /* Style for the IGC file button; also centered and separated */
        #popupMenu button#igcFileButton {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #eee;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 15px;  /* extra top margin to separate from the config buttons */
            cursor: pointer;
        }
        #popupMenu button#igcFileButton:hover {
            background: #ddd;
        }

        /* Style for the close button in the popup menu using a Material Icon */
        #popupMenu .popup-content .close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #000;
        }

        /* Dark mode styling for the popup (like the dock) */
        @media (prefers-color-scheme: dark) {
            #popupMenu .popup-content {
                background: rgba(20, 20, 20, 0.9);
                color: #fff;
            }
            #popupMenu #configButtons button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu #configButtons button:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu button#igcFileButton {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu button#igcFileButton:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu .popup-content .close {
                color: #fff;
            }
        }

        /* ===== Spinner Styling ===== */
        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            display: none; /* Hidden by default */
        }
        .spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Common style for configuration buttons */
        .config-button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        .config-button:hover {
            background: #ddd;
        }

        @media (prefers-color-scheme: dark) {
            .config-button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            .config-button:hover {
                background: rgba(20, 20, 20, 1);
            }
        }
    </style>
</head>
<body>
    <!-- Transparent Loading/Connection Message on Top of the Map -->
    <div id="loadingMessage" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 1000; background: rgba(255,255,255,0.8); padding: 10px 20px; border-radius: 3px; font-family: sans-serif; display: none;">
        Loading files, please wait...
    </div>

    <!-- Spinner for GeoJSON loading -->
    <div id="spinner">
        <div class="spinner"></div>
    </div>

    <div id="map"></div>

    <!-- Transparent Box on Bottom Left with Big Bold Text -->
    <div id="parametersBox" style="position: absolute; bottom: 10px; left: 10px; z-index: 1; background: rgba(255, 255, 255, 0.5); padding: 10px; border-radius: 5px; font-family: sans-serif; font-weight: bold; font-size: 24px; color: #000;">
        glide parameters
    </div>

    <!-- Map Dock: Controls always visible -->
    <div id="mapDock">
        <!-- Toggle Visibility for main layers -->
        <button title="Toggle Layer Visibility" id="toggleLayerButton">
            <span class="material-icons-round" id="visibilityIcon">visibility</span>
        </button>
        
        <!-- New Button to Toggle the Polygon Layer -->
        <button title="Toggle Polygon Layer" id="togglePolygonButton">
            <span class="material-icons-round" id="polygonVisibilityIcon">layers</span>
        </button>
        
        <!-- Slider wrapper for polygon opacity -->
        <div class="dock-slider">
            <input id="polygonOpacitySlider" type="range" min="0" max="0.5" step="0.01" value="0.1">
        </div>
        
        <!-- New Zoom Buttons replacing the text size buttons -->
        <button title="Zoom In" id="zoomInBtn">
            <span class="material-icons-round">zoom_in</span>
        </button>
        <button title="Zoom Out" id="zoomOutBtn">
            <span class="material-icons-round">zoom_out</span>
        </button>
        <button title="More Options" id="moreOptionsBtn">
            <span class="material-icons-round">menu</span>
        </button>
    </div>

    <!-- Popup Menu: For controls not requiring constant map visibility -->
    <div id="popupMenu">
        <div class="popup-content">
            <h3>Text Size</h3>
            <!-- Text Size Controls moved from the dock to the top of the popup -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <button title="Increase Text Size" id="textIncreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_plus_1</span>
                </button>
                <button title="Decrease Text Size" id="textDecreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_minus_1</span>
                </button>
            </div>
            <button class="close" id="closePopupBtn">
                <span class="material-icons-round">close</span>
            </button>
            <h3>Select Glide ratio</h3>
            <div id="configButtons"></div>
            <!-- IGC File Control with Icon -->
            <button id="igcFileButton">
                <span class="material-icons-round">folder_open</span>
                <span>Open IGC File</span>
            </button>
            <h3>Warning</h3>
            <p>This is a new experimental tool. Problems will arise that have not been encountered before in the gliding community.</p>
            <p>I am not sure that 100m above ground is big enough a margin to be safe above the passes.</p>
            <p>Airspace is not taken into account. Downdrafts are not taken into account.</p>
            <p>The airfield list might not be accurate, some airfields might be unservicable or closed.</p>
            <p>Check on a real map that the indications make sense.</p>
            <p>Speak with the owner of the glider (your club's instructors for example) about using this tool. They might foresee problems that you and the author has not anticipated and save your life.</p>
            <p>The author of this tool is not liable for any damage or injury that might occur by using this tool.</p>
            <!-- Hidden file input triggered by the IGC file button -->
            <input type="file" id="igcFileInput" accept="*/*" style="display: none;">
        </div>
    </div>

    <script>
        // Global variable to hold the current config folder name.
        var currentConfig = '20-100-250-4200';

        const customStyle = {
            "version": 8,
            "name": "Custom Map",
            "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
            "sources": {
                "custom-tiles": {
                    "type": "raster",
                    "tiles": [
                        "./tiles/{z}/{x}/{y}.png"  // Relative path to your tiles folder on GitHub Pages
                    ],
                    "tileSize": 256,
                    "maxzoom": 12,  // This ensures that even if you zoom past level 12, the map uses these tiles.
                    "attribution": "Map data © OpenStreetMap contributors + Alos topographic data"
                }
            },
            "layers": [
                {
                    "id": "custom-tiles",
                    "type": "raster",
                    "source": "custom-tiles",
                    "minzoom": 0   // Remove maxzoom here so the layer remains visible at higher zooms
                }
            ]
        };

        
        // Declare map in the global scope.
        let map;
        
        // Helper to update the parameters box text based on the config folder.
        function updateParametersBox(cfg) {
            const parts = cfg.split('-'); // e.g. ["20", "100", "250", "4200"]
            if (parts.length >= 3) {
                const labelText = "L/D " + parts[0] + " - ground " + parts[1] + "m - circuit " + parts[2] + "m";
                document.getElementById('parametersBox').textContent = labelText;
            }
        }
        
        // Call updateParametersBox at startup.
        updateParametersBox(currentConfig);
        
        // Function to remove static GeoJSON layers and sources.
        function removeGeoJSONLayers() {
            const layersToRemove = [
                'linestrings-layer',
                'linestrings-labels',
                'points-layer',
                'points-labels',
                'points-layer-clickable',
                'polygons-layer'
            ];
            layersToRemove.forEach(id => {
                if (map.getLayer(id)) {
                    map.removeLayer(id);
                }
            });
            const sourcesToRemove = ['geojson-data', 'polygons'];
            sourcesToRemove.forEach(id => {
                if (map.getSource(id)) {
                    map.removeSource(id);
                }
            });
        }
        
        // Function to remove dynamic layers added when clicking a point.
        function removeDynamicLayers() {
            // Remove dynamic layers (their id starts with "dynamic-lines-")
            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if(layer.id.startsWith('dynamic-lines-')) {
                    if(map.getLayer(layer.id)) { 
                        map.removeLayer(layer.id);
                    }
                }
            });
            
            // Remove the dynamic sources; we iterate over all source names.
            const sourceIds = Object.keys(map.style.sourceCaches);
            sourceIds.forEach(sourceId => {
                if(sourceId.startsWith('dynamic-lines-')) {
                    if(map.getSource(sourceId)) { 
                        map.removeSource(sourceId);
                    }
                }
            });
        }
        
        // Global variable for the base text size that all labels will use.
        let baseTextSize = 14; // Default value; adjust as desired

        // Function that iterates over the map's layers and updates the 'text-size' of any symbol layer
        // If the layer ID is "points-labels", we add 5 to baseTextSize.
        function updateAllLabelSizes() {
            // Iterate over all layers in the current map style.
            map.getStyle().layers.forEach(layer => {
                if (layer.type === 'symbol' && layer.layout && layer.layout["text-size"] !== undefined) {
                    // For the points labels, use baseTextSize + 5.
                    if (layer.id === 'points-labels') {
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize + 5);
                    } else {
                        // For all other symbol layers (lines labels, dynamic labels, altitude labels, etc.), use baseTextSize.
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize);
                    }
                }
            });
        }

        // Function to add (or update) GeoJSON layers using the current configuration folder.
        function addGeoJSONLayers() {
            // Rebuild the config prefix from the current config
            const configPrefix = currentConfig.split('-').slice(0, 3).join('-');

            // Add or update the main GeoJSON source.
            if (!map.getSource('geojson-data')) {
                map.addSource('geojson-data', {
                    type: 'geojson',
                    data: currentConfig + '/aa_alps_' + configPrefix + '.geojson'
                });
            } else {
                map.getSource('geojson-data').setData(currentConfig + '/aa_alps_' + configPrefix + '.geojson');
            }
            
            // Add or update the polygons source.
            if (!map.getSource('polygons')) {
                map.addSource('polygons', {
                    type: 'geojson',
                    data: currentConfig + '/aa_alps_' + configPrefix + '_sectors1.geojson'
                });
            } else {
                map.getSource('polygons').setData(currentConfig + '/aa_alps_' + configPrefix + '_sectors1.geojson');
            }
            
            // ---------------------------------------------------------------------
            // First load the polygon layer so that it renders underneath subsequent layers.
            if (!map.getLayer('polygons-layer')) {
                map.addLayer({
                    id: 'polygons-layer',
                    type: 'fill',
                    source: 'polygons',
                    paint: {
                        'fill-color': [
                            "match",
                            ["get", "color_id"],
                            0, "#0000FF",
                            1, "#FF00FF",
                            2, "#FFFF00",
                            3, "#00FFFF",
                            4, "#00FF00",
                            5, "#FF0000",
                            6, "#FFA500",
                            "#000000"
                        ],
                        'fill-opacity': 0.1
                    }
                });
            }
            
            // ---------------------------------------------------------------------
            // Add non-label layers (features) next.
            if (!map.getLayer('linestrings-layer')) {
                map.addLayer({
                    id: 'linestrings-layer',
                    type: 'line',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });
            }
            
            if (!map.getLayer('points-layer')) {
                map.addLayer({
                    id: 'points-layer',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#ff0000',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#fff'
                    }
                });
            }
            
            if (!map.getLayer('points-layer-clickable')) {
                map.addLayer({
                    id: 'points-layer-clickable',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 20,
                        'circle-color': '#000000',
                        'circle-opacity': 0
                    }
                });
            }
            
            // ---------------------------------------------------------------------
            // Now add the label layers so they always render on top.
            if (!map.getLayer('linestrings-labels')) {
                map.addLayer({
                    id: 'linestrings-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
            
            if (!map.getLayer('points-labels')) {
                map.addLayer({
                    id: 'points-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 7,
                    filter: ['==', '$type', 'Point'],
                    layout: {
                        'text-field': '{name}',
                        'text-size': baseTextSize + 5,
                        'text-allow-overlap': false,
                        'text-ignore-placement': true,
                        'text-offset': [0.8, 0.8]
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
        }
        
        // Function to switch the data configuration.
        function switchConfig(cfg) {
            // Remove any dynamic layers (e.g. from previous point clicks).
            removeDynamicLayers();
            // Remove the current static layers so they can be reloaded.
            removeGeoJSONLayers();
            // Update the parameters box based on the new config folder.
            updateParametersBox(cfg);
            // Update the global variable.
            currentConfig = cfg;
            addGeoJSONLayers();
        }
        
        // Updated dynamic point click handler to use the current config folder.
        function handlePointClick(e) {
            console.log("Point clicked event:", e);
            if (!e.features || !e.features.length) return;
        
            const feature = e.features[0];
            if (!feature.properties || !feature.properties.filename) {
                console.warn("Clicked feature missing 'filename' property:", feature);
                return;
            }

            // Build the file path and dynamic layer IDs.
            const filePath = currentConfig + "/" + feature.properties.filename;
            const dynamicLayerId = 'dynamic-lines-' + currentConfig + '-' + feature.properties.filename;
            const dynamicSourceId = dynamicLayerId + '-source';
            const dynamicLabelId = dynamicLayerId + '-labels';

            // -- Hide any dynamic layers (and their corresponding labels) that are NOT the one for this point --
            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if (layer.id.startsWith('dynamic-lines-') && layer.id !== dynamicLayerId) {
                    if (map.getLayer(layer.id)) {
                        map.setLayoutProperty(layer.id, 'visibility', 'none');
                    }
                    // Assume that label layers have the suffix "-labels" attached to the dynamic layer ID.
                    const otherLabelId = layer.id + '-labels';
                    if (map.getLayer(otherLabelId)) {
                        map.setLayoutProperty(otherLabelId, 'visibility', 'none');
                    }
                }
            });

            // -- If the dynamic layer for this point exists, toggle its visibility. --
            if (map.getLayer(dynamicLayerId)) {
                let currentVisibility = map.getLayoutProperty(dynamicLayerId, 'visibility') || 'visible';
                if (currentVisibility === 'visible') {
                    // If clicking the same point again: hide the dynamic layer and restore the main linestring layer.
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'none');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'visible');
                    }
                } else {
                    // If the dynamic layer exists but is hidden, show it and hide the main linestring layer.
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'visible');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                    }
                }
            } else {
                // -- Dynamic layer not yet created --
                // Hide the main linestring layer when showing a dynamic one.
                if (map.getLayer('linestrings-layer')) {
                    map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                }
                if (map.getLayer('linestrings-labels')) {
                    map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                }
                console.log("Adding dynamic layer for:", filePath);
                // Add the dynamic source.
                map.addSource(dynamicSourceId, {
                    type: 'geojson',
                    data: filePath
                });

                // Add the dynamic line layer.
                map.addLayer({
                    id: dynamicLayerId,
                    type: 'line',
                    source: dynamicSourceId,
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });

                // Add the corresponding dynamic label layer.
                map.addLayer({
                    id: dynamicLabelId,
                    type: 'symbol',
                    source: dynamicSourceId,
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }

            // Update the main linestring visibility icon based on current state.
            const mainVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
            document.getElementById('visibilityIcon').textContent = mainVisibility === 'visible' ? 'visibility' : 'visibility_off';
        }
        
        // Set up config buttons in the popup menu.
        // Available config folders.
        const availableConfigs = [
            '30-100-250-4200',
            '25-100-250-4200',
            '20-100-250-4200',
            '10-100-250-4200'
        ];
        
        const configButtonsContainer = document.getElementById('configButtons');
        availableConfigs.forEach(cfg => {
            const btn = document.createElement('button');
            // Use only the first part of the folder name as the button label (e.g., "30", "25", "20", or "10").
            btn.textContent = cfg.split('-')[0];
            btn.addEventListener('click', () => {
                switchConfig(cfg);
                document.getElementById('popupMenu').style.display = "none";
                console.log("Switched to configuration: " + cfg);
            });
            configButtonsContainer.appendChild(btn);
        });
        
        // Now that our helper functions and event listeners are set up,
        // initialize the map. (Ensure any variables like currentStyle are defined or adjust as needed.)
        const currentStyle = customStyle ;
        
        map = new maplibregl.Map({
            container: 'map',
            style: currentStyle,
            bounds: [[4.9698169, 43.6088902], [13.696105, 47.5644488]],
            maxBounds: [[4.57526, 43.45699], [13.96581, 47.98810]],
            maxZoom: 16,  // The user can zoom in further; level 12 tiles will be overscaled
            fitBoundsOptions: {
                padding: 50,
                maxZoom: 12,  // fitBounds will not zoom past level 12 unless you override this
                duration: 1000
            },
            attributionControl: false,
            renderWorldCopies: false
        });
        
        // --- GeoJSON Spinner Logic with Debounce ---
        // This Set will track only GeoJSON sources that are still loading.
        var loadingGeojsonSources = new Set();
        // Timer to debounce spinner display
        var spinnerTimeout = null;

        map.on('sourcedata', function(e) {
            // Only process events for sources (not individual tiles) and where the source type is "geojson".
            if (e.dataType !== 'source' || !e.source || e.source.type !== 'geojson') {
                return;
            }
            if (!e.isSourceLoaded) {
                loadingGeojsonSources.add(e.sourceId);
            } else {
                loadingGeojsonSources.delete(e.sourceId);
            }
            
            // If any GeoJSON sources are still loading, set a timer to show the spinner
            if (loadingGeojsonSources.size > 0) {
                if (!spinnerTimeout) {
                    spinnerTimeout = setTimeout(() => {
                        document.getElementById('spinner').style.display = 'block';
                    }, 200);
                }
            } else {
                // All GeoJSON sources are loaded: clear the timer and hide the spinner
                clearTimeout(spinnerTimeout);
                spinnerTimeout = null;
                document.getElementById('spinner').style.display = 'none';
            }
        });
        
        // Attach layers and events once the map has fully loaded.
        map.on('load', () => {
            addGeoJSONLayers();
            // Attach the click handler to the clickable layer.
            if (map.getLayer('points-layer-clickable')) {
                map.on('click', 'points-layer-clickable', handlePointClick);
            } else {
                console.warn("points-layer-clickable not found on map load.");
            }
            if (navigator.onLine) {
                map.once('idle', hideLoadingMessage);
            }
        });
        

        // Function to show the loading message with a given text.
        function showLoadingMessage(text) {
            const messageDiv = document.getElementById('loadingMessage');
            messageDiv.textContent = text;
            messageDiv.style.display = "block";
        }

        // Function to hide the loading message.
        function hideLoadingMessage() {
            document.getElementById('loadingMessage').style.display = "none";
        }

        // --- Connection Message Logic ---
        function updateConnectionMessage() {
            const messageDiv = document.getElementById('loadingMessage');
            if (!navigator.onLine) {
                messageDiv.textContent = "No internet connection. Please connect to the internet.";
                messageDiv.style.display = "block";
            } else {
                messageDiv.style.display = "none";
            }
        }

        updateConnectionMessage();

        window.addEventListener('offline', updateConnectionMessage);
        window.addEventListener('online', updateConnectionMessage);

        const polygonOpacitySlider = document.getElementById('polygonOpacitySlider');
        polygonOpacitySlider.addEventListener('input', function() {
            const opacity = parseFloat(this.value);
            if (map.getLayer('polygons-layer')) {
                map.setPaintProperty('polygons-layer', 'fill-opacity', opacity);
            }
        });

        // Toggle the popup menu
        const popupMenu = document.getElementById('popupMenu');
        document.getElementById('moreOptionsBtn').addEventListener('click', () => {
            popupMenu.style.display = "flex";
        });
        document.getElementById('closePopupBtn').addEventListener('click', () => {
            popupMenu.style.display = "none";
        });

        // Close popup when clicking outside the popup content
        popupMenu.addEventListener('click', (e) => {
            if(e.target === popupMenu) {
                popupMenu.style.display = "none";
            }
        });

        // --- IGC File Functionality (ported from production) ---

        // Function to parse IGC file and convert to GeoJSON
        function igcToGeoJSON(igcContent) {
            // Parse IGC file content
            const lines = igcContent.split('\n');
            const coordinates = [];
            let metadata = {};

            for (const line of lines) {
                // Handle B records (position fixes)
                if (line.startsWith('B')) {
                    try {
                        // Extract time (HHMMSS)
                        const time = line.substring(1, 7);
                        // Extract latitude (DDMMmmmN/S)
                        const latRaw = line.substring(7, 15);
                        const latDeg = parseInt(latRaw.substring(0, 2));
                        const latMin = parseFloat(latRaw.substring(2, 7)) / 1000;
                        const latDir = latRaw.substring(7, 8);
                        // Extract longitude (DDDMMmmmE/W)
                        const lonRaw = line.substring(15, 24);
                        const lonDeg = parseInt(lonRaw.substring(0, 3));
                        const lonMin = parseFloat(lonRaw.substring(3, 8)) / 1000;
                        const lonDir = lonRaw.substring(8, 9);
                        // Extract altitude (AAAAA)
                        const altPressure = parseInt(line.substring(25, 30));
                        const altGNSS = parseInt(line.substring(30, 35));

                        // Convert latitude to decimal
                        let latitude = latDeg + (latMin / 60);
                        if (latDir === 'S') latitude = -latitude;

                        // Convert longitude to decimal
                        let longitude = lonDeg + (lonMin / 60);
                        if (lonDir === 'W') longitude = -longitude;

                        // Use GNSS altitude if available, otherwise use pressure altitude
                        const altitude = altPressure > 0 ? altPressure : altGNSS;

                        coordinates.push([longitude, latitude, altitude]);
                    } catch (error) {
                        console.warn('Error parsing B record:', line, error);
                    }
                }
                // Handle H records (header/metadata)
                else if (line.startsWith('H')) {
                    try {
                        const headerType = line.substring(1, 5);
                        const headerValue = line.substring(5).trim();

                        if (headerType.startsWith('FDT')) metadata.date = headerValue;
                        if (headerType.startsWith('FPL')) metadata.pilot = headerValue;
                        if (headerType.startsWith('FGT')) metadata.gliderType = headerValue;
                        if (headerType.startsWith('FGI')) metadata.gliderID = headerValue;
                    } catch (error) {
                        console.warn('Error parsing H record:', line, error);
                    }
                }
            }

            // Create GeoJSON object
            const geojson = {
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    },
                    properties: {
                        ...metadata,
                        sourceFormat: 'IGC',
                        coordinateProperties: {
                            altitudes: coordinates.map(coord => coord[2])
                        }
                    }
                }]
            };

            return geojson;
        }

        // Replace your current handleFileSelect with the following enhanced version.
        // It reads the IGC file, converts it to GeoJSON, adds a new line layer (with blue color),
        // computes its bounding box, recenters the map, and adds altitude labels.
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Close the popup menu after a file has been selected.
            document.getElementById('popupMenu').style.display = "none";
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const igcContent = e.target.result;
                const geojsonData = igcToGeoJSON(igcContent);
                console.log('Converted IGC to GeoJSON:', geojsonData);
                
                // Generate a dynamic layer ID from the file name (strip non-alphanumeric characters)
                const baseLayerId = 'igc-layer-' + file.name.replace(/\W/g, '');
                let layerId = baseLayerId;
                // If a layer with the same ID exists, append a timestamp
                if (map.getLayer(layerId)) {
                    layerId = baseLayerId + '-' + Date.now();
                }
                const sourceId = layerId + '-source';
                
                // Add a new source and corresponding line layer to the map for the IGC flight track
                map.addSource(sourceId, {
                    type: 'geojson',
                    data: geojsonData
                });
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#0000FF',
                        'line-width': 2
                    }
                });
                
                // Compute the bounding box of the IGC track based on its coordinates
                const coords = geojsonData.features[0].geometry.coordinates;
                let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
                coords.forEach(coord => {
                    const [lng, lat] = coord;
                    if (lng < minLng) minLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lng > maxLng) maxLng = lng;
                    if (lat > maxLat) maxLat = lat;
                });
                const bounds = [[minLng, minLat], [maxLng, maxLat]];
                
                // Recenter the map so that the IGC track fits within the view
                map.fitBounds(bounds, {
                    padding: 50,
                    maxZoom: 14,
                    duration: 1000
                });
                
                // Create altitude point features based on each vertex of the IGC LineString.
                const altPoints = {
                    type: 'FeatureCollection',
                    features: coords.map(coord => ({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [coord[0], coord[1]]
                        },
                        properties: {
                            altitude: coord[2]
                        }
                    }))
                };

                // Add a new source for the altitude labels
                const altSourceId = layerId + '-altitudes-source';
                map.addSource(altSourceId, {
                    type: 'geojson',
                    data: altPoints
                });

                // Add a symbol layer to display the altitude at each point (visible for zoom > 9)
                map.addLayer({
                    id: layerId + '-altitudes',
                    type: 'symbol',
                    source: altSourceId,
                    minzoom: 9,
                    layout: {
                        'text-field': '{altitude}',
                        'text-size': baseTextSize, // Use the base text size for altitude labels
                        'text-offset': [0, -0.5]
                    },
                    paint: {
                        'text-color': '#0000FF',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            };
            reader.readAsText(file);
        }

        // Wire up the IGC file button (in your popup menu) and file input
        document.getElementById('igcFileButton').addEventListener('click', function() {
            document.getElementById('igcFileInput').click();
            this.blur(); // Remove focus so the button doesn't stay highlighted.
        });
        document.getElementById('igcFileInput').addEventListener('change', handleFileSelect);

        // Toggle layer visibility for main linestrings layers and their labels
        document.getElementById('toggleLayerButton').addEventListener('click', () => {
            // Only include linestrings layers and labels in the toggle action.
            const layerIds = ['linestrings-layer', 'linestrings-labels'];
            // Determine the new visibility based on the current state of the "linestrings-layer".
            let newVisibility = 'visible';
            if (map.getLayer('linestrings-layer')) {
                const currentVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
                newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            }
            // Toggle the visibility of the specified layers.
            layerIds.forEach(id => {
                if (map.getLayer(id)) {
                    map.setLayoutProperty(id, 'visibility', newVisibility);
                }
            });
            // Update the icon text accordingly.
            document.getElementById('visibilityIcon').textContent = newVisibility === 'visible' ? 'visibility' : 'visibility_off';
        });
        // Zoom Button Event Listeners (newly added)
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            map.zoomIn();
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            map.zoomOut();
        });

        // Text Size Control Event Listeners (moved to the popup)
        document.getElementById('textDecreaseBtn').addEventListener('click', () => {
            baseTextSize = Math.max(1, baseTextSize - 1);
            updateAllLabelSizes();
        });

        // Increase Text Size Button event listener
        document.getElementById('textIncreaseBtn').addEventListener('click', () => {
            baseTextSize += 1;
            updateAllLabelSizes();
        });

        // Toggle the polygon layer visibility
        document.getElementById('togglePolygonButton').addEventListener('click', () => {
            const polygonLayerId = 'polygons-layer';
            // Get current visibility, assume "visible" if not explicitly set.
            let currentVisibility = map.getLayoutProperty(polygonLayerId, 'visibility') || 'visible';
            // Toggle visibility.
            let newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            map.setLayoutProperty(polygonLayerId, 'visibility', newVisibility);
            // Update the icon accordingly (using "layers" for visible and "layers_clear" for hidden).
            document.getElementById('polygonVisibilityIcon').textContent = newVisibility === 'visible' ? 'layers' : 'layers_clear';
        });

        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/MountainCircles---map/sw.js')
                .then(function(registration) {
                    console.log('Service Worker registered with scope:', registration.scope);
                })
                .catch(function(error) {
                    console.error('Service Worker registration failed:', error);
                });
        }

    </script>
</body>
</html>