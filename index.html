<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="/MountainCircles---map/">
    <title>MountainCircles Map - Beta</title>
    <!-- Using jsDelivr instead of unpkg to avoid potential network errors on Windows -->
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="MC Map">
    <meta name="theme-color" content="#000000">
    <style>
        body { margin: 0; padding: 0; }
        #map { width: 100%; height: 100vh; }
        /* Simple style for the basemap switcher */
        #styleSwitcher {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
        }
        /* Container uses flex, aligning items in the center vertically */
        #polygonOpacityControl {
            position: absolute;
            top: 50px;
            right: 10px;
            z-index: 1;
            background: #fff;
            padding: 5px;
            border-radius: 3px;
            font-family: sans-serif;
            box-shadow: 0 1px 4px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
        }
        /* Make the button a flex container so its content centers */
        #polygonOpacityControl button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin-right: 5px;
            background: none;
            border: none;
            cursor: pointer;
            min-height: 24px; /* ensures the button is at least 24px tall */
        }
        /* Force the Material Icons font with !important */
        .material-icons-round {
            font-family: 'Material Icons Round' !important;
            font-size: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            color: #000;
        }
        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- MAP DOCK (apple-dock style) --------------- */
        #mapDock {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            flex-direction: column;
            max-height: 100%;
            flex-wrap: wrap-reverse;
            gap: 10px;
            z-index: 1100;
        }

        /* -------------------------- */
        /* Slider Container (Dock Box) */
        /* -------------------------- */
        .dock-slider {
            width: 48px;       /* Same as other button width */
            height: 150px;     /* Give enough room for the rotated slider */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.8); /* Light mode: white-ish background */
            border-radius: 8px;
            padding: 8px;
            box-sizing: border-box;
        }

        /* Slider styling remains the same in landscape mode */
        #polygonOpacitySlider {
            width: 150px;  /* Length of the slider track */
            -webkit-transform: rotate(-90deg);
            -ms-transform: rotate(-90deg);
            transform: rotate(-90deg);
            -webkit-appearance: none; /* Remove default styling */
            background: transparent;  /* Needed for custom pseudo-elements */
        }

        /* Portrait mode: dock is horizontal, so the slider must be horizontal */
        @media (orientation: portrait) {
            #mapDock {
                position: fixed;
                top: 10px;
                left: 0;
                right: 0;
                width: 100%;
                padding: 0 0; /* Optional: Add some horizontal spacing */
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center; /* Center items in each row */
                gap: 10px;
                transform: translateY(0);
            }
            .dock-slider {
                /* Adjust container to have the same height as other buttons */
                width: 150px;
                height: 48px;
                background: rgba(255, 255, 255, 0.8);
                border-radius: 8px;
                padding: 8px;
                box-sizing: border-box;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            /* Force the slider to be horizontal by resetting its rotation */
            .dock-slider #polygonOpacitySlider {
                -webkit-transform: rotate(0deg) !important;
                -ms-transform: rotate(0deg) !important;
                transform: rotate(0deg) !important;
                width: 100% !important;
            }
        }

        /* Dark mode adjustments: use a grey background similar to the buttons */
        @media (prefers-color-scheme: dark) {
            .dock-slider {
                background: rgba(20, 20, 20, 0.8);
            }
        }

        /* ===================== */
        /* Custom Slider Styling */
        /* ===================== */

        /* For Webkit Browsers (Chrome, Safari, Opera) */
        #polygonOpacitySlider::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            margin-top: -7px; /* Center the thumb on the track */
            cursor: pointer;
        }

        /* For Firefox */
        #polygonOpacitySlider::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* For IE */
        #polygonOpacitySlider::-ms-track {
            width: 100%;
            height: 6px;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }
        #polygonOpacitySlider::-ms-fill-lower {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-fill-upper {
            background: #ccc;
            border-radius: 3px;
        }
        #polygonOpacitySlider::-ms-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
        }

        /* Dark mode adjustments: use a darker grey for the slider track */
        @media (prefers-color-scheme: dark) {
            #polygonOpacitySlider::-webkit-slider-runnable-track {
                background: #555;
            }
            #polygonOpacitySlider::-moz-range-track {
                background: #555;
            }
            #polygonOpacitySlider::-ms-fill-lower,
            #polygonOpacitySlider::-ms-fill-upper {
                background: #555;
            }
        }


        /* Map Dock Buttons: Remove transition and hover effects */
        #mapDock button {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            outline: none;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: none;  /* Disabled transition for scaling and background changes */
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #mapDock button:hover {
            transform: none;   /* Disable zooming (scaling) */
            background: rgba(255, 255, 255, 0.8);  /* Keep same background */
        }

        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            #mapDock button {
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock button:hover {
                transform: none;   /* Disable zooming in dark mode as well */
                background: rgba(20, 20, 20, 0.8);
            }
            #mapDock .material-icons-round {
                color: #fff;
            }
        }

        /* --------------- POPUP MENU (centered on screen) --------------- */
        #popupMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.2);
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            z-index: 1200;
        }
        #popupMenu .popup-content {
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            max-width: 400px;
            width: 90%;
            max-height: 60%; /* Limit the height to 90% of the viewport height */
            overflow-y: auto; /* Add vertical scrolling if content overflows */
            position: relative;
            font-family: sans-serif;
            text-align: center;
            color: #000;
        }
        
        /* Config buttons container: centers buttons and adds gap with extra bottom margin */
        #popupMenu #configButtons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;  /* 5px gap between config buttons */
            margin-bottom: 15px;
        }

        /* Style for configuration buttons inside the popup menu */
        #popupMenu #configButtons button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;  /* fallback margin, in addition to the flex gap */
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        #popupMenu #configButtons button:hover {
            background: #ddd;
        }

        /* Style for the IGC file button; also centered and separated */
        #popupMenu button#igcFileButton {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #eee;
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            margin-top: 15px;  /* extra top margin to separate from the config buttons */
            cursor: pointer;
        }
        #popupMenu button#igcFileButton:hover {
            background: #ddd;
        }

        /* Style for the close button in the popup menu using a Material Icon */
        #popupMenu .popup-content .close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #000;
        }

        /* Dark mode styling for the popup (like the dock) */
        @media (prefers-color-scheme: dark) {
            #popupMenu .popup-content {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu #configButtons button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu #configButtons button:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu button#igcFileButton {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #popupMenu button#igcFileButton:hover {
                background: rgba(20, 20, 20, 1);
            }
            #popupMenu .popup-content .close {
                color: #fff;
            }
        }

        /* ===== Spinner Styling ===== */
        #spinner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            display: none; /* Hidden by default */
        }
        .spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Common style for configuration buttons */
        .config-button {
            display: inline-block;
            padding: 12px 20px;
            font-size: 18px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background: #eee;
            cursor: pointer;
        }
        .config-button:hover {
            background: #ddd;
        }

        @media (prefers-color-scheme: dark) {
            .config-button {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            .config-button:hover {
                background: rgba(20, 20, 20, 1);
            }
        }

        .policy-section {
            margin-bottom: 20px;
        }
        
        .policy-section h3 {
            margin-bottom: 10px;
            text-align: center;
        }
        
        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            .policy-section h3 {
                color: #fff;
            }
        }

        /* Style for layer toggle buttons */
        #peaksToggleBtn, #passesToggleBtn {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
        }

        #peaksToggleBtn .material-icons-round,
        #passesToggleBtn .material-icons-round {
            font-size: 20px;
        }

        /* Dark mode adjustments */
        @media (prefers-color-scheme: dark) {
            #peaksToggleBtn, #passesToggleBtn {
                background: rgba(20, 20, 20, 0.8);
                color: #fff;
            }
            #peaksToggleBtn:hover, #passesToggleBtn:hover {
                background: rgba(20, 20, 20, 1);
            }
        }

        /* Update the CSS for the cache button */
        #cacheCurrentConfigBtn {
            transition: border 0.3s, box-shadow 0.3s;
            border: none;
            box-shadow: none;
            padding: 8px 12px;
            border-radius: 4px;
            position: relative; /* Ensure border works correctly */
            box-sizing: border-box; /* Include border in element size */
        }

        /* Style for cached configuration buttons */
        .cached-config {
            border: 2px solid #4CAF50; /* Green border */
        }

        /* Add to your existing CSS */
        #cacheProgress {
            display: none;
            flex-direction: column;
            width: 100%;
            align-items: center;
            margin-top: 10px;
        }

        .progress-bar-container {
            width: 80%;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <!-- Spinner for GeoJSON loading -->
    <div id="spinner">
        <div class="spinner"></div>
    </div>

    <div id="map"></div>

    <!-- Transparent Box on Bottom Left with Big Bold Text -->
    <div id="parametersBox" style="position: absolute; bottom: 10px; left: 10px; z-index: 1; background: rgba(255, 255, 255, 0.5); padding: 10px; border-radius: 5px; font-family: sans-serif; font-weight: bold; font-size: 24px; color: #000;">
        glide parameters
    </div>

    <!-- Map Dock: Controls always visible -->
    <div id="mapDock">
        <!-- Toggle Visibility for main layers -->
        <button title="Toggle Layer Visibility" id="toggleLayerButton">
            <span class="material-icons-round" id="visibilityIcon">visibility</span>
        </button>
        
        <!-- New Button to Toggle the Polygon Layer -->
        <button title="Toggle Polygon Layer" id="togglePolygonButton">
            <span class="material-icons-round" id="polygonVisibilityIcon">layers</span>
        </button>
        
        <!-- Slider wrapper for polygon opacity -->
        <div class="dock-slider">
            <input id="polygonOpacitySlider" type="range" min="0" max="0.5" step="0.01" value="0.1">
        </div>
        
        <!-- New Zoom Buttons replacing the text size buttons -->
        <button title="Zoom In" id="zoomInBtn">
            <span class="material-icons-round">zoom_in</span>
        </button>
        <button title="Zoom Out" id="zoomOutBtn">
            <span class="material-icons-round">zoom_out</span>
        </button>
        <button title="More Options" id="moreOptionsBtn">
            <span class="material-icons-round">menu</span>
        </button>
    </div>

    <!-- Popup Menu: For controls not requiring constant map visibility -->
    <div id="popupMenu">
        <div class="popup-content">
            <h3>Text Size</h3>
            <!-- Text Size Controls moved from the dock to the top of the popup -->
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 10px;">
                <button title="Increase Text Size" id="textIncreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_plus_1</span>
                </button>
                <button title="Decrease Text Size" id="textDecreaseBtn" class="config-button">
                    <span class="material-icons-round">exposure_minus_1</span>
                </button>
            </div>
            <button class="close" id="closePopupBtn">
                <span class="material-icons-round">close</span>
            </button>
            <h3>Select Glide ratio</h3>
            <div id="policyConfigs"></div>
            <h3>Layers</h3>
            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 15px;">
                <button id="peaksToggleBtn" class="config-button">
                    <span class="material-icons-round" id="peaksVisibilityIcon">terrain</span>
                    Peaks
                </button>
                <button id="passesToggleBtn" class="config-button">
                    <span class="material-icons-round" id="passesVisibilityIcon">route</span>
                    Passes
                </button>
            </div>
            <!-- IGC File Control with Icon -->
            <button id="igcFileButton">
                <span class="material-icons-round">folder_open</span>
                <span>Open IGC File</span>
            </button>
            <!-- Add this after the IGC File button in the popup menu -->
            <div style="margin-top: 15px; display: none;">
                <button id="cacheCurrentConfigBtn" class="config-button" style="display: flex; align-items: center; gap: 8px;">
                    <span class="material-icons-round">download</span>
                    <span>Cache Current Config for Offline Use</span>
                </button>
                <div id="cacheProgress" style="display: none; margin-top: 10px;">
                    <div style="margin-bottom: 5px;">Caching files: <span id="cacheCount">0</span>/<span id="totalFiles">0</span></div>
                    <div style="width: 100%; height: 4px; background: #eee; border-radius: 2px;">
                        <div id="progressBar" style="width: 0%; height: 100%; background: #4CAF50; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>

            <!-- Add new section for caching background map -->
            <div style="margin-top: 15px; display: none;">
                <button id="cacheBackgroundMapBtn" class="config-button" style="display: flex; align-items: center; gap: 8px;">
                    <span class="material-icons-round">map</span>
                    <span>Cache Background Map for Offline Use</span>
                </button>
                <div id="mapCacheProgress" style="display: none; margin-top: 10px;">
                    <div style="margin-bottom: 5px;">Caching tiles: <span id="mapCacheCount">0</span>/<span id="mapTotalTiles">0</span></div>
                    <div style="width: 100%; height: 4px; background: #eee; border-radius: 2px;">
                        <div id="mapProgressBar" style="width: 0%; height: 100%; background: #4CAF50; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>

            <h3>Warning</h3>
            <p>This is a new experimental tool. Problems will arise that have not been encountered before in the gliding community.</p>
            <p>I am not sure that 100m above ground is big enough a margin to be safe above the passes.</p>
            <p>Airspace is not taken into account. Downdrafts are not taken into account. Wind is not taken into account.</p>
            <p>The airfield list might not be accurate, some airfields might be unservicable or closed.</p>
            <p>Check on a real map that the indications make sense.</p>
            <p>Speak with the owner of the glider (your club's instructors for example) about using this tool. They might foresee problems that you and the author have not anticipated and save your life.</p>
            <p>The author is not liable for any damage or injury that might occur by using this tool.</p>
            <!-- Hidden file input triggered by the IGC file button -->
            <input type="file" id="igcFileInput" accept="*/*" style="display: none;">
        </div>
    </div>

    <!-- Add this right after the opening <body> tag -->
    <div id="installPrompt" style="display: none; position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 8px; z-index: 1000; text-align: center;">
        <p style="margin: 0 0 10px 0;">Install MountainCircles Map for offline use?</p>
        <button id="installButton" style="background: #4CAF50; border: none; color: white; padding: 8px 16px; border-radius: 4px; margin-right: 10px;">Install</button>
        <button id="cancelInstall" style="background: #666; border: none; color: white; padding: 8px 16px; border-radius: 4px;">Not Now</button>
    </div>

    <script>
        const BASE_PATH = '/MountainCircles---map';

        const customStyle = {
            "version": 8,
            "name": "Custom Map",
            "glyphs": "https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf",
            "sources": {
                "custom-tiles": {
                    "type": "raster",
                    "tiles": [
                        "./tiles/{z}/{x}/{y}.png"  // Relative path to your tiles folder on GitHub Pages
                    ],
                    "tileSize": 256,
                    "maxzoom": 12,  // This ensures that even if you zoom past level 12, the map uses these tiles.
                    "attribution": "Map data © OpenStreetMap contributors + Alos topographic data"
                }
            },
            "layers": [
                {
                    "id": "custom-tiles",
                    "type": "raster",
                    "source": "custom-tiles",
                    "minzoom": 0   // Remove maxzoom here so the layer remains visible at higher zooms
                }
            ]
        };
        const policies = {
            'alps': [
                '10-100-250-4200',
                '20-100-250-4200',
                '25-100-250-4200',
                '30-100-250-4200',
            ],
            'West_alps_with_fields': [
                '10-100-250-4200',
                '20-100-250-4200',
                '25-100-250-4200',
                '30-100-250-4200',
            ]
        };


        // Update the currentConfig to include policy
        let currentPolicy = 'alps';  // Default policy
        let currentConfig = currentPolicy + '/' + '20-100-250-4200';  // Default config with policy prefix

        // Create policy sections and their config buttons
        const policyConfigsContainer = document.getElementById('policyConfigs');
        
        Object.entries(policies).forEach(([policy, configs]) => {
            // Create section for this policy
            const policySection = document.createElement('div');
            policySection.className = 'policy-section';
            
            // Add policy header
            const policyHeader = document.createElement('h3');
            policyHeader.textContent = policy;
            policySection.appendChild(policyHeader);
            
            // Create container for this policy's config buttons
            const configButtonsContainer = document.createElement('div');
            configButtonsContainer.className = 'config-buttons';
            configButtonsContainer.style.display = 'flex';
            configButtonsContainer.style.flexWrap = 'wrap';
            configButtonsContainer.style.justifyContent = 'center';
            configButtonsContainer.style.gap = '5px';
            configButtonsContainer.style.marginBottom = '15px';
            
            // Add config buttons for this policy
            configs.forEach(cfg => {
                const btn = document.createElement('button');
                btn.textContent = cfg.split('-')[0];  // Use first part as button label
                btn.className = 'config-button';
                const fullConfig = policy + '/' + cfg;  // Store the full config path
                
                // Set the data-config attribute explicitly
                btn.setAttribute('data-config', fullConfig);
                
                btn.onclick = () => {
                    switchConfig(fullConfig);
                    document.getElementById('popupMenu').style.display = "none";
                    console.log("Switched to configuration: " + fullConfig);
                };
                configButtonsContainer.appendChild(btn);
            });
            
            policySection.appendChild(configButtonsContainer);
            policyConfigsContainer.appendChild(policySection);
        });

        // Initialize visibility state
        let peaksVisible = true;
        let passesVisible = true;

        // Function to update layer visibility and icon
        function updateLayerVisibility(layerId, visible, iconId) {
            if (map.getLayer(layerId)) {
                map.setLayoutProperty(layerId, 'visibility', visible ? 'visible' : 'none');
                document.getElementById(iconId).style.opacity = visible ? '1' : '0.5';
            }
        }

        // Peaks toggle button
        document.getElementById('peaksToggleBtn').addEventListener('click', () => {
            peaksVisible = !peaksVisible;
            updateLayerVisibility('peaks-symbols', peaksVisible, 'peaksVisibilityIcon');
        });

        // Passes toggle button
        document.getElementById('passesToggleBtn').addEventListener('click', () => {
            passesVisible = !passesVisible;
            updateLayerVisibility('passes-symbols', passesVisible, 'passesVisibilityIcon');
        });

        // Update the switchConfig function to maintain visibility state
        function switchConfig(cfg) {
            removeDynamicLayers();
            removeGeoJSONLayers();
            updateParametersBox(cfg.split('/')[1]);
            currentConfig = cfg;
            currentPolicy = cfg.split('/')[0];
            addGeoJSONLayers();
            
            // Restore visibility states after adding layers
            updateLayerVisibility('peaks-symbols', peaksVisible, 'peaksVisibilityIcon');
            updateLayerVisibility('passes-symbols', passesVisible, 'passesVisibilityIcon');
            
            // Move layers to top in correct order
            if (map.getLayer('passes-symbols')) {
                map.moveLayer('passes-symbols');
            }
            if (map.getLayer('peaks-symbols')) {
                map.moveLayer('peaks-symbols');
            }
            if (map.getLayer('location-marker-circle')) {
                map.moveLayer('location-marker-circle');
            }

            // Update cache button style when config changes
            if (isRunningStandalone() && isMobileDevice()) {
                updateCacheButtonStyle();
            }
        }

        // Update addGeoJSONLayers to use the policy name in file paths
        function addGeoJSONLayers() {
            const configParts = currentConfig.split('/');
            const configPrefix = configParts[1].split('-').slice(0, 3).join('-');
            const policyName = configParts[0]; // Convert policy name to lowercase for filenames

            if (!map.getSource('geojson-data')) {
                map.addSource('geojson-data', {
                    type: 'geojson',
                    data: currentConfig + '/aa_' + policyName + '_' + configPrefix + '.geojson'
                });
            } else {
                map.getSource('geojson-data').setData(currentConfig + '/aa_' + policyName + '_' + configPrefix + '.geojson');
            }
            
            if (!map.getSource('polygons')) {
                map.addSource('polygons', {
                    type: 'geojson',
                    data: currentConfig + '/aa_' + policyName + '_' + configPrefix + '_sectors1.geojson'
                });
            } else {
                map.getSource('polygons').setData(currentConfig + '/aa_' + policyName + '_' + configPrefix + '_sectors1.geojson');
            }
            
            // ---------------------------------------------------------------------
            // First load the polygon layer so that it renders underneath subsequent layers.
            if (!map.getLayer('polygons-layer')) {
                map.addLayer({
                    id: 'polygons-layer',
                    type: 'fill',
                    source: 'polygons',
                    paint: {
                        'fill-color': [
                            "match",
                            ["get", "color_id"],
                            0, "#0000FF",
                            1, "#FF00FF",
                            2, "#FFFF00",
                            3, "#00FFFF",
                            4, "#00FF00",
                            5, "#FF0000",
                            6, "#FFA500",
                            "#000000"
                        ],
                        'fill-opacity': 0.1
                    }
                });
            }
            
            // ---------------------------------------------------------------------
            // Add non-label layers (features) next.
            if (!map.getLayer('linestrings-layer')) {
                map.addLayer({
                    id: 'linestrings-layer',
                    type: 'line',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });
            }
            
            if (!map.getLayer('points-layer')) {
                map.addLayer({
                    id: 'points-layer',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#ff0000',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#fff'
                    }
                });
            }
            
            if (!map.getLayer('points-layer-clickable')) {
                map.addLayer({
                    id: 'points-layer-clickable',
                    type: 'circle',
                    source: 'geojson-data',
                    filter: ['==', '$type', 'Point'],
                    paint: {
                        'circle-radius': 20,
                        'circle-color': '#000000',
                        'circle-opacity': 0
                    }
                });
            }
            
            // ---------------------------------------------------------------------
            // Now add the label layers so they always render on top.
            if (!map.getLayer('linestrings-labels')) {
                map.addLayer({
                    id: 'linestrings-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
            
            if (!map.getLayer('points-labels')) {
                map.addLayer({
                    id: 'points-labels',
                    type: 'symbol',
                    source: 'geojson-data',
                    minzoom: 7,
                    filter: ['==', '$type', 'Point'],
                    layout: {
                        'text-field': '{name}',
                        'text-size': baseTextSize + 5,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0.8, 0.8],
                        'text-variable-anchor': ['top', 'bottom', 'left', 'right'],
                        'text-radial-offset': 0.8,
                        'symbol-spacing': 20
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }
        }
        
        // Declare map in the global scope.
        let map;
        
        // Helper to update the parameters box text based on the config folder.
        function updateParametersBox(cfg) {
            console.log("updateParametersBox called with:", cfg);
            // First split by '/' to remove the policy
            const configOnly = cfg.split('/')[1] || cfg;  // Take second part after slash, or whole string if no slash
            // Then split the config numbers
            const parts = configOnly.split('-');
            console.log("parts after split:", parts);
            if (parts.length >= 3) {
                const labelText = "L/D " + parts[0] + "-ground " + parts[1] + "m-circuit " + parts[2] + "m";
                console.log("setting label to:", labelText);
                document.getElementById('parametersBox').textContent = labelText;
            }
        }
        
        // Call updateParametersBox at startup.
        updateParametersBox(currentConfig);
        
        // Function to remove static GeoJSON layers and sources.
        function removeGeoJSONLayers() {
            const layersToRemove = [
                'linestrings-layer',
                'linestrings-labels',
                'points-layer',
                'points-labels',
                'points-layer-clickable',
                'polygons-layer'
            ];
            layersToRemove.forEach(id => {
                if (map.getLayer(id)) {
                    map.removeLayer(id);
                }
            });
            const sourcesToRemove = ['geojson-data', 'polygons'];
            sourcesToRemove.forEach(id => {
                if (map.getSource(id)) {
                    map.removeSource(id);
                }
            });
        }
        
        // Function to remove dynamic layers added when clicking a point.
        function removeDynamicLayers() {
            // Remove dynamic layers (their id starts with "dynamic-lines-")
            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if(layer.id.startsWith('dynamic-lines-')) {
                    if(map.getLayer(layer.id)) { 
                        map.removeLayer(layer.id);
                    }
                }
            });
            
            // Remove the dynamic sources; we iterate over all source names.
            const sourceIds = Object.keys(map.style.sourceCaches);
            sourceIds.forEach(sourceId => {
                if(sourceId.startsWith('dynamic-lines-')) {
                    if(map.getSource(sourceId)) { 
                        map.removeSource(sourceId);
                    }
                }
            });
        }
        
        // Global variable for the base text size that all labels will use.
        let baseTextSize = 14; // Default value; adjust as desired

        // Function that iterates over the map's layers and updates the 'text-size' of any symbol layer
        // If the layer ID is "points-labels", we add 5 to baseTextSize.
        function updateAllLabelSizes() {
            // Iterate over all layers in the current map style.
            map.getStyle().layers.forEach(layer => {
                if (layer.type === 'symbol' && layer.layout && layer.layout["text-size"] !== undefined) {
                    // For the points labels, use baseTextSize + 5.
                    if (layer.id === 'points-labels') {
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize + 5);
                    } else {
                        // For all other symbol layers (lines labels, dynamic labels, altitude labels, etc.), use baseTextSize.
                        map.setLayoutProperty(layer.id, 'text-size', baseTextSize);
                    }
                }
            });
        }

        // Updated dynamic point click handler to use the current config folder.
        function handlePointClick(e) {
            console.log("Point clicked event:", e);
            if (!e.features || !e.features.length) return;
        
            const feature = e.features[0];
            if (!feature.properties || !feature.properties.filename) {
                console.warn("Clicked feature missing 'filename' property:", feature);
                return;
            }

            // Build the file path and dynamic layer IDs.
            const filePath = currentConfig + "/" + feature.properties.filename;
            const dynamicLayerId = 'dynamic-lines-' + currentConfig + '-' + feature.properties.filename;
            const dynamicSourceId = dynamicLayerId + '-source';
            const dynamicLabelId = dynamicLayerId + '-labels';

            // -- Hide any dynamic layers (and their corresponding labels) that are NOT the one for this point --
            const currentLayers = map.getStyle().layers.slice();
            currentLayers.forEach(layer => {
                if (layer.id.startsWith('dynamic-lines-') && layer.id !== dynamicLayerId) {
                    if (map.getLayer(layer.id)) {
                        map.setLayoutProperty(layer.id, 'visibility', 'none');
                    }
                    // Assume that label layers have the suffix "-labels" attached to the dynamic layer ID.
                    const otherLabelId = layer.id + '-labels';
                    if (map.getLayer(otherLabelId)) {
                        map.setLayoutProperty(otherLabelId, 'visibility', 'none');
                    }
                }
            });

            // -- If the dynamic layer for this point exists, toggle its visibility. --
            if (map.getLayer(dynamicLayerId)) {
                let currentVisibility = map.getLayoutProperty(dynamicLayerId, 'visibility') || 'visible';
                if (currentVisibility === 'visible') {
                    // If clicking the same point again: hide the dynamic layer and restore the main linestring layer.
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'none');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'visible');
                    }
                } else {
                    // If the dynamic layer exists but is hidden, show it and hide the main linestring layer.
                    map.setLayoutProperty(dynamicLayerId, 'visibility', 'visible');
                    if (map.getLayer(dynamicLabelId)) {
                        map.setLayoutProperty(dynamicLabelId, 'visibility', 'visible');
                    }
                    if (map.getLayer('linestrings-layer')) {
                        map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                    }
                    if (map.getLayer('linestrings-labels')) {
                        map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                    }
                }
            } else {
                // -- Dynamic layer not yet created --
                // Hide the main linestring layer when showing a dynamic one.
                if (map.getLayer('linestrings-layer')) {
                    map.setLayoutProperty('linestrings-layer', 'visibility', 'none');
                }
                if (map.getLayer('linestrings-labels')) {
                    map.setLayoutProperty('linestrings-labels', 'visibility', 'none');
                }
                console.log("Adding dynamic layer for:", filePath);
                // Add the dynamic source.
                map.addSource(dynamicSourceId, {
                    type: 'geojson',
                    data: filePath
                });

                // Add the dynamic line layer.
                map.addLayer({
                    id: dynamicLayerId,
                    type: 'line',
                    source: dynamicSourceId,
                    filter: ['==', '$type', 'LineString'],
                    paint: {
                        'line-color': '#000',
                        'line-width': ['step', ['zoom'], 1, 10, 2]
                    }
                });

                // Add the corresponding dynamic label layer.
                map.addLayer({
                    id: dynamicLabelId,
                    type: 'symbol',
                    source: dynamicSourceId,
                    minzoom: 8,
                    filter: ['==', '$type', 'LineString'],
                    layout: {
                        'text-field': '{ELEV}',
                        'symbol-placement': 'line',
                        'text-rotation-alignment': 'auto',
                        'text-keep-upright': true,
                        'text-size': baseTextSize,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-offset': [0, 0],
                        'symbol-spacing': 250
                    },
                    paint: {
                        'text-color': '#000',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
            }

            // Move peaks and location marker to the top after adding or modifying layers
            if (map.getLayer('passes-symbols')) {
                map.moveLayer('passes-symbols');
            }
            if (map.getLayer('peaks-symbols')) {
                map.moveLayer('peaks-symbols');
            }
            if (map.getLayer('location-marker-circle')) {
                map.moveLayer('location-marker-circle');
            }

            // Update the main linestring visibility icon based on current state.
            const mainVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
            document.getElementById('visibilityIcon').textContent = mainVisibility === 'visible' ? 'visibility' : 'visibility_off';
        }
        
        // Now that our helper functions and event listeners are set up,
        // initialize the map. (Ensure any variables like currentStyle are defined or adjust as needed.)
        const currentStyle = customStyle ;
        
        map = new maplibregl.Map({
            container: 'map',
            style: currentStyle,
            bounds: [[4.9698169, 43.6088902], [13.696105, 47.5644488]],
            maxBounds: [[4.57526, 43.45699], [13.96581, 47.98810]],
            maxZoom: 16,  // The user can zoom in further; level 12 tiles will be overscaled
            fitBoundsOptions: {
                padding: 50,
                maxZoom: 12,  // fitBounds will not zoom past level 12 unless you override this
                duration: 1000
            },
            attributionControl: false,
            renderWorldCopies: false
        });
        
        // --- GeoJSON Spinner Logic with Debounce ---
        // This Set will track only GeoJSON sources that are still loading.
        var loadingGeojsonSources = new Set();
        // Timer to debounce spinner display
        var spinnerTimeout = null;

        map.on('sourcedata', function(e) {
            // Only process events for sources (not individual tiles) and where the source type is "geojson".
            if (e.dataType !== 'source' || !e.source || e.source.type !== 'geojson') {
                return;
            }
            if (!e.isSourceLoaded) {
                loadingGeojsonSources.add(e.sourceId);
            } else {
                loadingGeojsonSources.delete(e.sourceId);
            }
            
            // If any GeoJSON sources are still loading, set a timer to show the spinner
            if (loadingGeojsonSources.size > 0) {
                if (!spinnerTimeout) {
                    spinnerTimeout = setTimeout(() => {
                        document.getElementById('spinner').style.display = 'block';
                    }, 200);
                }
            } else {
                // All GeoJSON sources are loaded: clear the timer and hide the spinner
                clearTimeout(spinnerTimeout);
                spinnerTimeout = null;
                document.getElementById('spinner').style.display = 'none';
            }
        });
        
        // Attach layers and events once the map has fully loaded.
        map.on('load', () => {
            console.log('Map load event triggered');
            
            // Add peaks and passes sources
            map.addSource('peaks', {
                type: 'geojson',
                data: 'peaks.geojson'
            });
            map.addSource('passes', {
                type: 'geojson',
                data: 'passes.geojson'
            });
            console.log('Added peaks and passes sources');

            // Create triangle images for peaks and passes
            const size = 15;
            const peakImage = new Image(size, size);
            const passImage = new Image(size, size);
            const peakCanvas = document.createElement('canvas');
            const passCanvas = document.createElement('canvas');
            peakCanvas.width = size;
            peakCanvas.height = size;
            passCanvas.width = size;
            passCanvas.height = size;
            const peakContext = peakCanvas.getContext('2d');
            const passContext = passCanvas.getContext('2d');
            
            // Draw orange upward triangle for peaks
            peakContext.beginPath();
            peakContext.moveTo(size/2, 0);
            peakContext.lineTo(size, size);
            peakContext.lineTo(0, size);
            peakContext.closePath();
            peakContext.fillStyle = '#FF8C00';  // Dark orange color (instead of #8B4513)
            peakContext.fill();
            
            // Draw green inverted triangle for passes
            passContext.beginPath();
            passContext.moveTo(0, 0);
            passContext.lineTo(size, 0);
            passContext.lineTo(size/2, size);
            passContext.closePath();
            passContext.fillStyle = '#006400';  // Dark green color
            passContext.fill();
            
            peakImage.src = peakCanvas.toDataURL();
            passImage.src = passCanvas.toDataURL();
            
            // Add image loading handlers
            Promise.all([
                new Promise(resolve => peakImage.onload = resolve),
                new Promise(resolve => passImage.onload = resolve)
            ]).then(() => {
                console.log('Triangle images loaded');
                map.addImage('peak-triangle', peakImage);
                map.addImage('pass-triangle', passImage);
                console.log('Added triangle images to map');

                // Add the peaks symbol layer
                map.addLayer({
                    id: 'peaks-symbols',
                    type: 'symbol',
                    source: 'peaks',
                    minzoom: 10,
                    layout: {
                        'icon-image': 'peak-triangle',
                        'icon-size': 1,
                        'icon-anchor': 'bottom',
                        'text-field': ['get', 'namele'],
                        'text-size': baseTextSize,
                        'text-anchor': 'top',
                        'text-offset': [0, 0.5],
                        'icon-allow-overlap': false,
                        'icon-ignore-placement': false,
                        'icon-optional': true,
                        'icon-padding': 2,
                        'symbol-spacing': 250,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-optional': true,
                        'text-padding': 2,
                        'text-field': [
                            'step',
                            ['zoom'],
                            '',  // Default (no text)
                            11, ['get', 'namele']  // At zoom 11 and above, show the name
                        ]
                    },
                    paint: {
                        'text-color': '#654321', 
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });

                // Add the passes symbol layer
                map.addLayer({
                    id: 'passes-symbols',
                    type: 'symbol',
                    source: 'passes',
                    minzoom: 10,
                    layout: {
                        'icon-image': 'pass-triangle',
                        'icon-size': 1,
                        'icon-anchor': 'top',  // Inverted triangle, so anchor at top
                        'text-field': ['get', 'name'],
                        'text-size': baseTextSize,
                        'text-anchor': 'bottom',  // Text below the triangle
                        'text-offset': [0, -0.5],
                        'icon-allow-overlap': false,
                        'icon-ignore-placement': false,
                        'icon-optional': true,
                        'icon-padding': 2,
                        'symbol-spacing': 250,
                        'text-allow-overlap': false,
                        'text-ignore-placement': false,
                        'text-optional': true,
                        'text-padding': 2,
                        'text-field': [
                            'step',
                            ['zoom'],
                            '',  // Default (no text)
                            11, ['get', 'name']  // At zoom 11 and above, show the name
                        ]
                    },
                    paint: {
                        'text-color': '#006400',  // Dark green color for pass labels
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });
                console.log('Added peaks and passes symbol layers');
            });

            // Then add your other layers
            addGeoJSONLayers();
            
            // Add location marker last
            map.addSource('location-marker', {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [0, 0]
                    }
                }
            });

            map.addLayer({
                id: 'location-marker-circle',
                type: 'circle',
                source: 'location-marker',
                paint: {
                    'circle-radius': 8,
                    'circle-color': '#0066FF',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#FFFFFF'
                }
            });

            // Start tracking location automatically
            if ('geolocation' in navigator) {
                const options = {
                    enableHighAccuracy: true,
                    maximumAge: 0,
                    timeout: 5000
                };
                
                navigator.geolocation.watchPosition(
                    updateLocation,
                    (error) => {
                        console.error('Error getting location:', error);
                    },
                    options
                );
            } else {
                console.warn('Geolocation is not supported by this browser.');
            }

            // Rest of the map.on('load') code...
            if (map.getLayer('points-layer-clickable')) {
                map.on('click', 'points-layer-clickable', handlePointClick);
            }

            // Update the cache button visibility check
            const cacheButton = document.getElementById('cacheCurrentConfigBtn');
            const mapCacheButton = document.getElementById('cacheBackgroundMapBtn');
            const cacheContainer = cacheButton.parentElement;
            const mapCacheContainer = mapCacheButton.parentElement;

            // Style the containers consistently
            [cacheContainer, mapCacheContainer].forEach(container => {
                container.style.display = 'none';  // Default to hidden
                container.style.justifyContent = 'center';
                container.style.alignItems = 'center';
                container.style.gap = '5px';
                container.style.marginBottom = '15px';
                container.style.width = '100%';
            });

            // Only show cache controls for installed mobile app
            if (isRunningStandalone() && isMobileDevice()) {
                cacheContainer.style.display = 'flex';  // Show with flex layout if conditions met
                mapCacheContainer.style.display = 'flex';
                // Hide zoom buttons in standalone mode
                document.getElementById('zoomInBtn').style.display = 'none';
                document.getElementById('zoomOutBtn').style.display = 'none';
            } 
        });
        
        // Helper function to check if running in standalone mode
        function isRunningStandalone() {
            return window.matchMedia('(display-mode: standalone)').matches ||
                   window.navigator.standalone ||  // for iOS
                   document.referrer.includes('android-app://');
        }

        const polygonOpacitySlider = document.getElementById('polygonOpacitySlider');
        polygonOpacitySlider.addEventListener('input', function() {
            const opacity = parseFloat(this.value);
            if (map.getLayer('polygons-layer')) {
                map.setPaintProperty('polygons-layer', 'fill-opacity', opacity);
            }
        });

        // Toggle the popup menu
        const popupMenu = document.getElementById('popupMenu');
        document.getElementById('moreOptionsBtn').addEventListener('click', () => {
            popupMenu.style.display = "flex";
            updateConfigButtonStyles();
        });
        document.getElementById('closePopupBtn').addEventListener('click', () => {
            popupMenu.style.display = "none";
        });

        // Close popup when clicking outside the popup content
        popupMenu.addEventListener('click', (e) => {
            if(e.target === popupMenu) {
                popupMenu.style.display = "none";
            }
        });

        // --- IGC File Functionality (ported from production) ---

        // Function to parse IGC file and convert to GeoJSON
        function igcToGeoJSON(igcContent) {
            // Parse IGC file content
            const lines = igcContent.split('\n');
            const coordinates = [];
            let metadata = {};

            for (const line of lines) {
                // Handle B records (position fixes)
                if (line.startsWith('B')) {
                    try {
                        // Extract time (HHMMSS)
                        const time = line.substring(1, 7);
                        // Extract latitude (DDMMmmmN/S)
                        const latRaw = line.substring(7, 15);
                        const latDeg = parseInt(latRaw.substring(0, 2));
                        const latMin = parseFloat(latRaw.substring(2, 7)) / 1000;
                        const latDir = latRaw.substring(7, 8);
                        // Extract longitude (DDDMMmmmE/W)
                        const lonRaw = line.substring(15, 24);
                        const lonDeg = parseInt(lonRaw.substring(0, 3));
                        const lonMin = parseFloat(lonRaw.substring(3, 8)) / 1000;
                        const lonDir = lonRaw.substring(8, 9);
                        // Extract altitude (AAAAA)
                        const altPressure = parseInt(line.substring(25, 30));
                        const altGNSS = parseInt(line.substring(30, 35));

                        // Convert latitude to decimal
                        let latitude = latDeg + (latMin / 60);
                        if (latDir === 'S') latitude = -latitude;

                        // Convert longitude to decimal
                        let longitude = lonDeg + (lonMin / 60);
                        if (lonDir === 'W') longitude = -longitude;

                        // Use GNSS altitude if available, otherwise use pressure altitude
                        const altitude = altPressure > 0 ? altPressure : altGNSS;

                        coordinates.push([longitude, latitude, altitude]);
                    } catch (error) {
                        console.warn('Error parsing B record:', line, error);
                    }
                }
                // Handle H records (header/metadata)
                else if (line.startsWith('H')) {
                    try {
                        const headerType = line.substring(1, 5);
                        const headerValue = line.substring(5).trim();

                        if (headerType.startsWith('FDT')) metadata.date = headerValue;
                        if (headerType.startsWith('FPL')) metadata.pilot = headerValue;
                        if (headerType.startsWith('FGT')) metadata.gliderType = headerValue;
                        if (headerType.startsWith('FGI')) metadata.gliderID = headerValue;
                    } catch (error) {
                        console.warn('Error parsing H record:', line, error);
                    }
                }
            }

            // Create GeoJSON object
            const geojson = {
                type: 'FeatureCollection',
                features: [{
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    },
                    properties: {
                        ...metadata,
                        sourceFormat: 'IGC',
                        coordinateProperties: {
                            altitudes: coordinates.map(coord => coord[2])
                        }
                    }
                }]
            };

            return geojson;
        }

        // Replace your current handleFileSelect with the following enhanced version.
        // It reads the IGC file, converts it to GeoJSON, adds a new line layer (with blue color),
        // computes its bounding box, recenters the map, and adds altitude labels.
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Close the popup menu after a file has been selected.
            document.getElementById('popupMenu').style.display = "none";
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const igcContent = e.target.result;
                const geojsonData = igcToGeoJSON(igcContent);
                console.log('Converted IGC to GeoJSON:', geojsonData);
                
                // Generate a dynamic layer ID from the file name (strip non-alphanumeric characters)
                const baseLayerId = 'igc-layer-' + file.name.replace(/\W/g, '');
                let layerId = baseLayerId;
                // If a layer with the same ID exists, append a timestamp
                if (map.getLayer(layerId)) {
                    layerId = baseLayerId + '-' + Date.now();
                }
                const sourceId = layerId + '-source';
                
                // Add a new source and corresponding line layer to the map for the IGC flight track
                map.addSource(sourceId, {
                    type: 'geojson',
                    data: geojsonData
                });
                map.addLayer({
                    id: layerId,
                    type: 'line',
                    source: sourceId,
                    paint: {
                        'line-color': '#0000FF',
                        'line-width': 2
                    }
                });
                
                // Compute the bounding box of the IGC track based on its coordinates
                const coords = geojsonData.features[0].geometry.coordinates;
                let minLng = Infinity, minLat = Infinity, maxLng = -Infinity, maxLat = -Infinity;
                coords.forEach(coord => {
                    const [lng, lat] = coord;
                    if (lng < minLng) minLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lng > maxLng) maxLng = lng;
                    if (lat > maxLat) maxLat = lat;
                });
                const bounds = [[minLng, minLat], [maxLng, maxLat]];
                
                // Recenter the map so that the IGC track fits within the view
                map.fitBounds(bounds, {
                    padding: 50,
                    maxZoom: 14,
                    duration: 1000
                });
                
                // Create altitude point features based on each vertex of the IGC LineString.
                const altPoints = {
                    type: 'FeatureCollection',
                    features: coords.map(coord => ({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [coord[0], coord[1]]
                        },
                        properties: {
                            altitude: coord[2]
                        }
                    }))
                };

                // Add a new source for the altitude labels
                const altSourceId = layerId + '-altitudes-source';
                map.addSource(altSourceId, {
                    type: 'geojson',
                    data: altPoints
                });

                // Add a symbol layer to display the altitude at each point (visible for zoom > 9)
                map.addLayer({
                    id: layerId + '-altitudes',
                    type: 'symbol',
                    source: altSourceId,
                    minzoom: 9,
                    layout: {
                        'text-field': '{altitude}',
                        'text-size': baseTextSize, // Use the base text size for altitude labels
                        'text-offset': [0, -0.5]
                    },
                    paint: {
                        'text-color': '#0000FF',
                        'text-halo-color': '#fff',
                        'text-halo-width': 2
                    }
                });

                // After adding all the new layers, move the location marker to the top
                if (map.getLayer('location-marker-circle')) {
                    map.moveLayer('location-marker-circle');
                }
            };
            reader.readAsText(file);
        }

        // Wire up the IGC file button (in your popup menu) and file input
        document.getElementById('igcFileButton').addEventListener('click', function() {
            document.getElementById('igcFileInput').click();
            this.blur(); // Remove focus so the button doesn't stay highlighted.
        });
        document.getElementById('igcFileInput').addEventListener('change', handleFileSelect);

        // Toggle layer visibility for main linestrings layers and their labels
        document.getElementById('toggleLayerButton').addEventListener('click', () => {
            // Only include linestrings layers and labels in the toggle action.
            const layerIds = ['linestrings-layer', 'linestrings-labels'];
            // Determine the new visibility based on the current state of the "linestrings-layer".
            let newVisibility = 'visible';
            if (map.getLayer('linestrings-layer')) {
                const currentVisibility = map.getLayoutProperty('linestrings-layer', 'visibility') || 'visible';
                newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            }
            // Toggle the visibility of the specified layers.
            layerIds.forEach(id => {
                if (map.getLayer(id)) {
                    map.setLayoutProperty(id, 'visibility', newVisibility);
                }
            });
            // Update the icon text accordingly.
            document.getElementById('visibilityIcon').textContent = newVisibility === 'visible' ? 'visibility' : 'visibility_off';
        });
        // Zoom Button Event Listeners (newly added)
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            map.zoomIn();
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            map.zoomOut();
        });

        // Text Size Control Event Listeners (moved to the popup)
        document.getElementById('textDecreaseBtn').addEventListener('click', () => {
            baseTextSize = Math.max(1, baseTextSize - 1);
            updateAllLabelSizes();
        });

        // Increase Text Size Button event listener
        document.getElementById('textIncreaseBtn').addEventListener('click', () => {
            baseTextSize += 1;
            updateAllLabelSizes();
        });

        // Toggle the polygon layer visibility
        document.getElementById('togglePolygonButton').addEventListener('click', () => {
            const polygonLayerId = 'polygons-layer';
            // Get current visibility, assume "visible" if not explicitly set.
            let currentVisibility = map.getLayoutProperty(polygonLayerId, 'visibility') || 'visible';
            // Toggle visibility.
            let newVisibility = currentVisibility === 'visible' ? 'none' : 'visible';
            map.setLayoutProperty(polygonLayerId, 'visibility', newVisibility);
            // Update the icon accordingly (using "layers" for visible and "layers_clear" for hidden).
            document.getElementById('polygonVisibilityIcon').textContent = newVisibility === 'visible' ? 'layers' : 'layers_clear';
        });

        // Add this near the top of your script
        let deferredPrompt;

        window.addEventListener('beforeinstallprompt', (e) => {
            // Only show install prompt on mobile devices
            if (isMobileDevice()) {
                // Stash the event so it can be triggered later
                deferredPrompt = e;
                
                // Show the install prompt
                document.getElementById('installPrompt').style.display = 'block';
            } else {
                // Hide the prompt on non-mobile devices
                document.getElementById('installPrompt').style.display = 'none';
            }
        });

        // Installation prompt handlers
        document.getElementById('installButton').addEventListener('click', async () => {
            if (deferredPrompt) {
                await deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                deferredPrompt = null;
                document.getElementById('installPrompt').style.display = 'none';
            }
        });

        document.getElementById('cancelInstall').addEventListener('click', () => {
            document.getElementById('installPrompt').style.display = 'none';
        });

        // Update your service worker registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register(`${BASE_PATH}/sw.js`, {
                scope: `${BASE_PATH}/`  // Add trailing slash
            })
            .then(async registration => {
                console.log('Service Worker registered with scope:', registration.scope);
                
                // Force update
                if (registration.active) {
                    registration.update();
                }
            })
            .catch(error => {
                console.error('Service Worker registration failed:', error);
            });
        }

        // Function to update location
        function updateLocation(position) {
            if (!map.getSource('location-marker')) {
                console.warn('Location marker source not found');
                return;
            }
            
            const coords = [position.coords.longitude, position.coords.latitude];
            
            // Update the marker position
            map.getSource('location-marker').setData({
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: coords
                }
            });
        }

        // Add this to your existing script section
        async function cacheConfigurationFiles() {
            const configParts = currentConfig.split('/');
            const policy = configParts[0];
            const config = configParts[1];
            const configPrefix = config.split('-').slice(0, 3).join('-');
            
            // Show progress UI
            document.getElementById('cacheProgress').style.display = 'block';
            const progressBar = document.getElementById('progressBar');
            const cacheCount = document.getElementById('cacheCount');
            const totalFiles = document.getElementById('totalFiles');
            
            try {
                // First, fetch the main GeoJSON to get the point features
                const mainGeojsonUrl = `./${currentConfig}/aa_${policy}_${configPrefix}.geojson`;
                const sectorsGeojsonUrl = `./${currentConfig}/aa_${policy}_${configPrefix}_sectors1.geojson`;
                
                const response = await fetch(mainGeojsonUrl);
                const data = await response.json();
                
                // Filter for point features that have a filename property
                const pointFeatures = data.features.filter(f => 
                    f.geometry.type === 'Point' && f.properties.filename);
                
                // Create list of files to cache, including the main GeoJSON files
                const files = [
                    `${currentConfig}/aa_${policy}_${configPrefix}.geojson`,
                    `${currentConfig}/aa_${policy}_${configPrefix}_sectors1.geojson`,
                    ...pointFeatures.map(f => `${currentConfig}/${f.properties.filename}`)
                ];
                
                // Update total files count (including main files)
                const total = files.length;
                totalFiles.textContent = total;
                
                // Create message handler before sending message
                const messageHandler = (event) => {
                    if (event.data.type === 'cacheStart') {
                        // alert(event.data.message);
                    }
                    else if (event.data.type === 'cacheProgress') {
                        // Update progress for every file
                        cacheCount.textContent = event.data.completed;
                        const percentage = (event.data.completed / event.data.total) * 100;
                        progressBar.style.width = `${percentage}%`;
                        
                        // Show alert for the current operation
                        if (event.data.message) {
                            // alert(event.data.message);
                        }
                    }
                    else if (event.data.type === 'cacheError') {
                        // alert(event.data.message);
                    }
                    else if (event.data.type === 'cacheComplete') {
                        // alert('Cache complete - updating button styles');
                        updateConfigButtonStyles();
                        navigator.serviceWorker.removeEventListener('message', messageHandler);
                        document.getElementById('cacheProgress').style.display = 'none';
                        progressBar.style.width = '0%';
                    }
                };
                
                // Add the message listener
                navigator.serviceWorker.addEventListener('message', messageHandler);
                
                // Send message to service worker
                const registration = await navigator.serviceWorker.ready;
                
                // alert('Sending cache request to Service Worker');
                registration.active.postMessage({
                    type: 'cacheFiles',
                    files: files,
                    config: currentConfig
                });
                
            } catch (error) {
                // alert(`Error: ${error.message}`);
                console.error('Error caching configuration:', error);
                document.getElementById('cacheProgress').style.display = 'none';
            }
        }

        // Add click handler for the cache button
        document.getElementById('cacheCurrentConfigBtn').addEventListener('click', cacheConfigurationFiles);

        // Add these functions at the top of your script section
        function isRunningStandalone() {
            return window.matchMedia('(display-mode: standalone)').matches || 
                   window.navigator.standalone || // for iOS
                   document.referrer.includes('android-app://');
        }

        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        /* Update the function to check if a configuration is cached */
        async function isConfigCached(config) {
            // alert('Checking cache for config: ' + config);
            const configParts = config.split('/');
            const policy = configParts[0];
            const configPrefix = configParts[1].split('-').slice(0, 3).join('-');
            const mainGeojsonUrl = `${BASE_PATH}/${config}/aa_${policy}_${configPrefix}.geojson`;
            // alert('Looking for URL in cache: ' + mainGeojsonUrl);
            
            try {
                const cache = await caches.open('mountaincircles-dynamic-v1');
                const response = await cache.match(mainGeojsonUrl);
                const isCached = !!response;
                // alert(`Cache result for ${mainGeojsonUrl}: ${isCached}`);
                return isCached;
            } catch (error) {
                // alert('Error checking cache: ' + error);
                return false;
            }
        }

        /* Update the button style function to only target config buttons */
        async function updateConfigButtonStyles() {
            // alert('Starting to update button styles');
            const buttons = document.querySelectorAll('.config-buttons .config-button');
            // alert(`Found ${buttons.length} config buttons`);
            
            for (const button of buttons) {
                const buttonConfig = button.getAttribute('data-config');
                // alert(`Checking button with config: ${buttonConfig}`);  // More detailed debug
                if (buttonConfig) {
                    const isCached = await isConfigCached(buttonConfig);
                    // alert(`Cache result for ${buttonConfig}: ${isCached}`);
                    button.style.border = isCached ? '2px solid #4CAF50' : 'none';
                } else {
                    // alert('Button has no config data!');  // Debug for missing data
                }

            }
            // alert('Finished updating button styles');
        }

        // Add this function after the cacheConfigurationFiles function
        async function cacheTiles() {
            // Show progress UI
            document.getElementById('mapCacheProgress').style.display = 'block';
            const progressBar = document.getElementById('mapProgressBar');
            const cacheCount = document.getElementById('mapCacheCount');
            const totalTiles = document.getElementById('mapTotalTiles');

            // Initial bounds from the map configuration
            const bounds = [[4.9698169, 43.6088902], [13.696105, 47.5644488]];
            const minZoom = 1;
            const maxZoom = 12;

            // Calculate tile coordinates for each zoom level
            const tiles = [];
            for (let z = minZoom; z <= maxZoom; z++) {
                // Convert bounds to tile coordinates
                const northwest = latLngToTile(bounds[0][1], bounds[0][0], z);
                const southeast = latLngToTile(bounds[1][1], bounds[1][0], z);

                // Calculate tile ranges
                const minX = Math.min(northwest.x, southeast.x);
                const maxX = Math.max(northwest.x, southeast.x);
                const minY = Math.min(northwest.y, southeast.y);
                const maxY = Math.max(northwest.y, southeast.y);

                // Add all tiles within the bounds at this zoom level
                for (let x = minX; x <= maxX; x++) {
                    for (let y = minY; y <= maxY; y++) {
                        tiles.push({ x, y, z });
                    }
                }
            }

            // Update total tiles count
            totalTiles.textContent = tiles.length;

            // Create message handler
            let completedTiles = 0;
            const messageHandler = (event) => {
                if (event.data.type === 'cacheTileComplete') {
                    completedTiles++;
                    cacheCount.textContent = completedTiles;
                    const percentage = (completedTiles / tiles.length) * 100;
                    progressBar.style.width = `${percentage}%`;

                    if (completedTiles === tiles.length) {
                        // All tiles cached
                        navigator.serviceWorker.removeEventListener('message', messageHandler);
                        document.getElementById('mapCacheProgress').style.display = 'none';
                        progressBar.style.width = '0%';
                    }
                }
            };

            // Add the message listener
            navigator.serviceWorker.addEventListener('message', messageHandler);

            // Send tiles to service worker for caching
            const registration = await navigator.serviceWorker.ready;
            registration.active.postMessage({
                type: 'cacheTiles',
                tiles: tiles,
                basePath: './tiles'
            });
        }

        // Helper function to convert lat/lng to tile coordinates
        function latLngToTile(lat, lng, zoom) {
            const n = Math.pow(2, zoom);
            const x = Math.floor((lng + 180) / 360 * n);
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);
            return { x, y };
        }

        // Add click handler for the cache background map button
        document.getElementById('cacheBackgroundMapBtn').addEventListener('click', cacheTiles);

        // Detect iOS devices
        function isIOS() {
          return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // Show custom instructions for iOS users
        if (isIOS()) {
          const installPrompt = document.getElementById('installPrompt');
          installPrompt.innerHTML = `
            <p>To install this app, tap the share button in Safari and then select "Add to Home Screen".</p>
            <button id="closeInstallPrompt" style="background: #666; color: #fff; padding: 8px 16px; border: none; border-radius: 4px;">Close</button>
          `;
          installPrompt.style.display = 'block';

          document.getElementById('closeInstallPrompt').addEventListener('click', function() {
            installPrompt.style.display = 'none';
          });
        }


    </script>
</body>
</html>

